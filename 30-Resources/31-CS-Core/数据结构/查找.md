# 查找的基本概念
- 查找表：用于查找的数据集合称为查找表
- 关键字：唯一标识该元素的某个数据项的值（主键）
## 查找的常见操作
1. 查找某个数据元素
2. 插入、删除某个数据元素
## 查找的评价指标
- 查找长度：需要对比关键字的次数
- 平均查找长度（ASL，Average Search Length）：所有查找过程中进行关键字比较次数的平均值。
$$ASL=\sum_{i=1}^{n}P_iC_i$$
- **通常考虑查找成功、查找失败两种情况下的ASL**
---
# 顺序查找
- 通常用于[[线性表]]
- 就是从头到尾、从尾到头遍历
## 使用哨兵
- 数组的0号位置设置哨兵，即要查找的元素
- ![](http://oss.pyaxy.xyz/img/20251207143937897.png)
- 直接返回元素下标，当查找到0位置时，则查找失败。
- 优点：无需判断是否越界，效率会高一些。
## 查找效率分析
- 查找成功：
	- ![](http://oss.pyaxy.xyz/img/20251207144232602.png)
- 查找失败：
	- ![](http://oss.pyaxy.xyz/img/20251207144313320.png)
## 顺序查找的优化（有序表）
- ![](http://oss.pyaxy.xyz/img/20251207144606355.png)
- ![](http://oss.pyaxy.xyz/img/20251207144647169.png)
## 顺序查找的优化（被查概率不等）
- 被查找概率大的元素放到考前的位置。
---
# 折半查找
## 算法思想
- 又称之为二分查找，仅适用于**有序**的**顺序表**，链表没有随机存储的特性，因此不适用。
- 使用两个指针low和high确定查找范围
```C
typdef struct{ // 查找表的数据结构
	ElemType *elem; // 元素
	int TableLen; // 大小
}SSTable;
int Binary_Search(SSTable L, ElemType key){
	int low=0, high=L.TableLen-1,mid;
	while(low<=high){
		mid = (low + high) / 2; // 取中间
		if(L.elem[mid]==key) 
			return mid; // 查找成功
		if(L.elem[mid] > key)
			high = mid - 1; // 在前半部查找
		else
			low = mid + 1; // 在后半部查找
	}
	return -1; // 查找失败
}
```
## 算法效率
- ![](http://oss.pyaxy.xyz/img/20251207145936891.png)
## 折半查找判定树的构造
- ![](http://oss.pyaxy.xyz/img/20251207150217704.png)
- 右子树节点数只会比左子树节点数大于1或者0
- 折半查找的判定树一定是**平衡二叉树**
	- **只有最下面一层是不满的**
	- 因此，元素个数为n时树高$h=\lceil log_2(n+1) \rceil$
- 折半查找判定树的关键字：左 < 中 < 右，满足**二叉排序树**的定义
	- 失败结点：n+1个（成功节点的空链域数量）
	- ![](http://oss.pyaxy.xyz/img/20251207150955842.png)
## 折半查找的时间复杂度
- ![](http://oss.pyaxy.xyz/img/20251207151119775.png)
---
# 分块查找
## 算法思想
- 又称索引顺序查找
- 按块分割数组，每个块存储这个块的最大元素和这个块的区间范围，并保证块间是有序的。
	- ![](http://oss.pyaxy.xyz/img/20251207151716746.png)
	- 查找过程：
		1. 在索引表中确定待查记录所属分块（顺序、折半）
		2. 在块内顺序查找
	- 若索引表不直接包含目标关键字，则折半查找索引表最终停在low>high，要在low指向的分块中查找。
## 查找效率分析
- ![](http://oss.pyaxy.xyz/img/20251207152841268.png)
---
# 二叉排序树
## 二叉排序树的定义
- 左子树所有节点值 < 根节点值 < 右子树节点值
	- ![](http://oss.pyaxy.xyz/img/20251207153438685.png)
	- 进行**中序遍历**，可以得到一个递增的序列
## 二叉排序树的查找
- 若树非空，目标值与根节点比较
	- 若相等，查找成功。
	- 若小于根节点，在左子树查找
	- 若大于根节点，在右子树查找
		- ![](http://oss.pyaxy.xyz/img/20251207153634992.png)
		- 迭代法空间复杂度为O(1)，递归法空间复杂度为O(h)
## 二叉排序树的插入
- ![](http://oss.pyaxy.xyz/img/20251207153829279.png)
## 二叉排序树的构造
- ![](http://oss.pyaxy.xyz/img/20251207154100333.png)
## 二叉排序树的删除
1. 若删除的节点为叶子节点，则直接删除。
2. 若删除的节点只有左子树或右子树，则将其左子树或者右子树直接替换其位置。
3. 若删除的节点既有左子树又有右子树，则令其直接前驱/后继替代，并删除这个直接前驱/后继，转化为第一、二种情况（直接前驱一定没有右子树/直接后继一定没有左子树，因为直接前驱为左子树中最大的元素，如果其有右子树，则他不是最大的，同理直接后继也一样）。
## 二叉排序树的查找效率
- ![](http://oss.pyaxy.xyz/img/20251207155349947.png)
- ![](http://oss.pyaxy.xyz/img/20251207155416637.png)
- ![](http://oss.pyaxy.xyz/img/20251207155550318.png)
---
# 平衡二叉树（AVL树）
## 平衡二叉树的定义
- 树上任一节点的左子树和右子树的高度之差不超过1.
- **节点的平衡因子**=左子树高-右子树高。
	- 因此平衡二叉树每个节点的平衡因子只可能为-1、0、1。
## 插入节点后如何保持平衡⚠️
1. 首先在插入点往回找到第一个不平衡节点，调整以该节点为根的子树（最小不平衡子树）
	-  ![](http://oss.pyaxy.xyz/img/20251207160144112.png)
	- 最小不平衡子树平衡后，其他节点也就平衡了
2. 如何调整最小不平衡子树A
	- LL：A的左孩子的左子树中插入导致的不平衡
		- ![](http://oss.pyaxy.xyz/img/20251207160735340.png)
	- RR：A的右孩子的右子树中插入导致的不平衡
		- ![](http://oss.pyaxy.xyz/img/20251207160931153.png)
	- 代码思路：
		- ![](http://oss.pyaxy.xyz/img/20251207161047822.png)
	- LR：A的左孩子的右子树中插入导致的不平衡
		- ![](http://oss.pyaxy.xyz/img/20251207161323653.png)
	- RL：A的右孩子的左子树中插入导致的不平衡
		- ![](http://oss.pyaxy.xyz/img/20251207161522996.png)
3. 总结
	- ![](http://oss.pyaxy.xyz/img/20251207161635473.png)
## 查找效率分析
- ![](http://oss.pyaxy.xyz/img/20251207164229851.png)
## 平衡二叉树的删除
- 删除节点后若导致不平衡，则需要调整平衡
1. 删除节点（二叉排序树的方法）
	1. 删除叶子节点，直接删。
	2. 删除的节点只有一个子树，用子树替代原来的位置。
	3. 若删除的节点有两棵子树，用前驱（后继）节点顶替，并转化为对前驱（后继）节点的删除。
2. 向上找到**最小不平衡子树**
3. 找最小不平衡子树下，“个头”最高的儿子、孙子
4. 根据**孙子的位置**，调整平衡（LL/RR/LR/RL）
5. 如果仍然不平衡，返回2（最小不平衡子树的平衡可能会导致树高变小，影响上层的平衡）
---
# 红黑树（RBT）
- 平衡二叉树每次插入、删除时会破坏“平衡”特性，需要频繁调整树的形态。
- **红黑树**：插入/删除时很少破坏“红黑”特性，无需频繁调整树的形态，即**插入/删除操作实现更方便**。
	- 平衡二叉树：适用于查为主、很少插入/删除的场景。
	- 红黑树：适用于插入/删除操作较多的场景。
## 红黑树的定义
- **红黑树也是一种二叉排序树**：左 < 根 < 右
- 与普通二叉排序树对比，红黑树它
	1. 每个节点是红色/黑色的
	2. 根节点是黑色的
	3. 叶结点（外部节点、NULL节点、失败节点）为黑色的
	4. 不存在两个相邻的红节点（红节点的父结点和孩子节点均为黑色）
	5. 对每个节点，从该节点到每个叶结点的简单路径上黑色结点的数量相同。
- 结点的**黑高**h：从某结点出发到达任一叶结点的路径上的黑节点总数。
	- ![](http://oss.pyaxy.xyz/img/20251207180158271.png)
## 红黑树的性质
1. 从根节点到叶结点的最长路径不大于最短路径的2倍（最长是每两个黑节点之间都有一个红节点，最短是没有红节点）
2. 有n个结点的红黑树高度`h<=2log2(n+1)` -> 红黑树的查找效率为log2(n)
	- ![](http://oss.pyaxy.xyz/img/20251207180323205.png)
## 红黑树的插入
- ![](http://oss.pyaxy.xyz/img/20251207173927547.png)
## 红黑树的删除（不一定考）
- 红黑树的删除操作的时间复杂度 = O(log2n)
- 红黑树上删除节点的处理方式和二叉排序树删除一样。
- 删除后若破坏红黑特性，则需要调整节点颜色、位置。
---
# B树
- 即m叉查找树
	- 策略：在m叉查找树中，规定**除了根节点外**，任何节点**至少有$\lceil m/2 \rceil$个分叉**，即至少含有**$\lceil m/2 \rceil - 1$个关键字**
	- 策略：m叉查找树中，每个节点的子树高度相同。
## B树的定义
- ![](http://oss.pyaxy.xyz/img/20251207210004553.png)
- ![](http://oss.pyaxy.xyz/img/20251207210134793.png)
- 核心特性：
	- 根节点的子树数大于2小于m，关键字数大于1小于m-1
	- 其他节点的子树数大于$\lceil m/2 \rceil$小于m
	- 任一节点，子树高度相同。
	- 关键字的值在节点内有序。
## B树的高度
- ![](http://oss.pyaxy.xyz/img/20251207210540038.png)
- ![](http://oss.pyaxy.xyz/img/20251207210552601.png)
- ![](http://oss.pyaxy.xyz/img/20251207210832666.png)
## B树的插入
- ![](http://oss.pyaxy.xyz/img/20251207211213968.png)
- 注意：**插入节点位置一定是最底层的“终端节点”处**
- ![](http://oss.pyaxy.xyz/img/20251207211354726.png)
- ![](http://oss.pyaxy.xyz/img/20251207211453930.png)
- ![](http://oss.pyaxy.xyz/img/20251207211540840.png)
- ![](http://oss.pyaxy.xyz/img/20251207211624800.png)
## B树的删除
- ![](http://oss.pyaxy.xyz/img/20251207212216468.png)
- ![](http://oss.pyaxy.xyz/img/20251207212236749.png)
- 删除终端节点时小于下限：
	1. ![](http://oss.pyaxy.xyz/img/20251207212343337.png)
	2. ![](http://oss.pyaxy.xyz/img/20251207212400853.png)
## B+树
- ![](http://oss.pyaxy.xyz/img/20251207212648121.png)
- B+树的本质：相当于分块查找
一棵m阶的B+树需要满足：
	1. 每个分支节点最多有m棵子树（孩子节点）。
	2. 非叶根结点至少有两棵子树，其他每个分支节点至少有$\lceil m/2 \rceil$棵子树。
	3. **节点的子树个数与关键字个数相同**
	4. 所有**叶子节点包含所有的关键字**及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且**相邻叶结点按大小顺序相互链接起来**（**支持顺序查找**）
## B+树 VS B树
- ![](http://oss.pyaxy.xyz/img/20251207213912776.png)
---
# 散列表
- 散列表：可以根据数据元素的关键字计算出它在散列表中的位置
- 散列函数：建立了关键字->存储地址到映射
- ![](http://oss.pyaxy.xyz/img/20251207214156362.png)
- 冲突：两个关键字计算出了同一个地址。
	- 减少冲突：构造更合适的散列函数
## 散列函数的构造
- 核心设计目标：减少冲突
- 要求：
	- 对所有的关键字生效。
	- 计算出的值在合法地址范围内。
	- 计算出的地址尽可能的均匀分布在整个地址空间。
	- 计算量应该尽可能简单
### 除留余数法
- 对质数p取余
- 取不大于表长的最接近的质数p
### 直接定址法
- H(key)=a*key+b
	- 计算最简单，但是若关键字分布不连续，会造成空间浪费。
### 数字分析法
- 若关键字集合已知，且关键字的某几个数码位分布均匀，则直接使用这几位数码位，比如手机尾号
### 平方取中法
- 适用范围：关键字的每位取值都不够均匀。
	- ![](http://oss.pyaxy.xyz/img/20251207215319128.png)
## 散列表处理冲突
### 拉链法
- 拉链：把所有冲突的元素存储在一个**链表**中。
	- ![](http://oss.pyaxy.xyz/img/20251207215833947.png)
### 开放定址法
- 基本思想：若发生了冲突，则给新元素找另一个空闲位置
- ![](http://oss.pyaxy.xyz/img/20251207220402372.png)
### 关于删除操作：
- ![](http://oss.pyaxy.xyz/img/20251207221108816.png)
### 探测序列的探测覆盖率
- 线性探测法：
	- ![](http://oss.pyaxy.xyz/img/20251207221810639.png)
- 平方探测法：
	- ![](http://oss.pyaxy.xyz/img/20251207221502137.png)
- 双散列法：
	- ![](http://oss.pyaxy.xyz/img/20251207221945928.png)
- 总结：
	- ![](http://oss.pyaxy.xyz/img/20251207222049220.png)
### 散列查处的性能分析
- ![](http://oss.pyaxy.xyz/img/20251207222506645.png)
- ![](http://oss.pyaxy.xyz/img/20251207222718671.png)
- 装填因子
	- ![](http://oss.pyaxy.xyz/img/20251207223012001.png)
- 聚集现象
	- ![](http://oss.pyaxy.xyz/img/20251207223231701.png)
	- ![](http://oss.pyaxy.xyz/img/20251207223705015.png)