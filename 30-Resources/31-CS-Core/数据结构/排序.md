# 什么是排序
- 排序：就是使表中的关键字**有序**排列。
## 排序的评价指标
- 时间复杂度
- 空间复杂度
- 稳定性
	- 同一关键字的元素排序前后相对位置是否保持变化
## 排序的分类
- 内部排序：数据在内存中
- 外部排序：数据太多，无法放入内存里
---
# 插入排序
- 将待排序的记录按关键字大小插入到前面已排好的子序列中，直到全部记录插入完成。
- 实现代码（不带哨兵）
```C
void InsertSort(int A[], int n){
	int i, j, temp;
	for(i = 1; i < n; i++){ // 将各个元素插入已排好的序列中
		if(A[i] < A[i-1]){  // 若 A[i] 关键字小于前驱
			temp = A[i];    // temp暂存 A[i]
			for(j = i - 1; j >= 0 && A[j] > temp; j--) // 检查前面已排好的元素
				A[j+1] = A[j]; // 所有大于 A[i] 的元素往后移位
			A[j+1] = temp; // 复制到插入位置
			}
		}
}
```
- 实现代码（带哨兵）
	- 主要区别：将0号位置空出来，当作哨兵，相当于上面的temp；
	- 优点：不需要再每次循环判断 j >= 0 
```C
void InsertSort(int A[], int n){
	int i, j;
	for(i = 2; i <= n; i++){ // 依次将 A[2]~A[n]插入到已排序序列
		if(A[i] < A[i - 1]){ // 若 A[i] 关键字小于前驱
			A[0] = A[i];	 // 哨兵暂存 A[i]
			for(j = i - 1; A[0] < A[j]; j--){ // 从后往前查找待插入位置
				A[j + 1] = A[j]; // 向后挪位
			}
			A[j + 1] = A[0]; // 插入
		}//endif
	}
}
```
## 效率分析
- 空间复杂度：O(1)；
- 时间复杂度：
	- 最好情况（全部顺序）：O(n)；
	- 最坏情况（全部逆序）：O(n^2)；
	- 平均复杂度：O(n^2)
- 稳定性：稳定
## 插入排序的优化
- 思路：先用折半查找找到应该插入的位置，再移动元素。
- 具体建议画图
	- 当 low > high 时查找停止，将low~i-1的所有元素全部右移，并将A0复制到low所在的位置
	- 当查到相同元素时，为了保证算法的“稳定性”，应该继续在mid的右边寻找插入位置。
	- ![](http://oss.pyaxy.xyz/img/20251208155653668.png)
- 代码
```C
void InsertSort(int A[], int n){
	int i, j, low, high, mid;
	for(i = 2;i <= n; i++){  // 依次将 A[2]~A[n]插入到已排序序列
		A[0] = A[i]; // 哨兵暂存 A[i]
		low = 1; high = i - 1; // 设置折半查找范围
		while(low <= high){ // 折半查找（增序）
			mid =( low + high) / 2; // 取中间值
			if(A[mid] > A[0]) high = mid - 1; // 查左边
			else low = mid + 1; // 查右边
		}
		for(j = i - 1; j >= high + 1; j--)
			A[j+1] = A[j]; // 移动元素
		A[high + 1] = A[0]; // 成功插入
	}
}
```
---
# 希尔排序（Shell Sort）
- 思想：先追求表中的元素部分有序，再追求全局有序
- 希尔排序：先将待排序表分割成若干形如`L[i, i+d, i+2d,...,i+kd]`的子表，对各个子表进行插入排序。**缩小增量d**，重复过程，直到d=1为止。
	- ![](http://oss.pyaxy.xyz/img/20251208161440779.png)
- 代码实现：
```C
void ShellSort(int A[], int n){
	int d, i, j; // d为步长
	// 哨兵法，数据存储位置为 1~n
	for(d = n / 2; d >= 1; d /= 2){ // 步长变化
		for(i = d + 1; i <= n; i++){
			if(A[i] < A[i - d]){ // A[i] 和 A[i-d]对比
				A[0] = A[i]; // 暂存 A[i] 
				for(j = i - d; j > 0 && A[0] < A[j]; j -= d)
					A[j + d] = A[j]; // 记录后移，注意步长为d
				A[j + d] = A[0]; // 插入
			}//endif
		}
	}
}
```
- 注：虽然使用了哨兵，但是还需要判断j>=0，因为j减小的步长不是1可能一下子就成负值了，不可能刚好减到0使A\[0]=A\[j]跳出循环。
## 效率分析
- 空间复杂度：O(1)
- 时间复杂度：和增量序列d的选择有关，目前无法用数学手段证明确切的时间复杂度
	- 最坏时间复杂度为：O(n^2)；
	- 当n在某个范围内时：可达到O(n^1.3)
- 稳定性：不稳定
---
# 冒泡排序
- 是一种交换排序。
- 从后往前两两比较相邻关键字的值，如果前面的大于后面的，则两者交换，直到序列遍历完成，称为一趟排序。
	- 第一趟排序后最小的元素会跑到第一位
	- 第二趟排序后最小的两个元素会跑到第一、二位
- 代码
```C
void BubbleSort(int A[], int n){
	for(int i = 0; i < n - 1; i++){
		bool flag = false; // 本趟排序是否产生交换
		for(int j = n - 1; j > i; j--) // 一趟过程
			if(A[j - 1] > A[j]){ // 若为逆序
				swap(A[j-1], A[j]); // 交换
				flag = true;
			}
		if(flag == true) // 本趟没有发生交换，说明已有序
			return;
	}
}
```
## 效率分析
- 空间复杂度：O(1)
- 时间复杂度：
	- 最好：O(n)；
	- 最坏：O(n^2)；
	- 平均：O(n^2)；
- 稳定性：稳定
- 注：每**交换**一次元素，会移动元素**三次**，注意审题
---
# 快速排序
- 算法思想：在待排序表L\[1…n]中任取⼀个元素**pivot作为枢轴**（或基准，通常取⾸元素），通过⼀趟排序将待排序表划分为独⽴的两部分L\[1…k-1]和L\[k+1…n]，使得L\[1…k-1]中的所有元素⼩于pivot，L\[k+1…n]中的所有元素⼤于等于pivot，则pivot放在了其最终位置L(k)上，这个过程称为⼀次“划分”。然后分别递归地对两个⼦表重复上述过程，直⾄每部分内只有⼀个元素或空为⽌，即所有元素放在了其最终位置上。
	- 左边更小，右边更大；
- 代码实现：
```C
// 用第一个元素将待排序序列划分为左右两个部分
int Partition(int A[], int low, int high){
	int pivot = A[low]; // 第一个元素作为pivot
	while(low < high){ // low和high开始移动
		while(low < high && A[high] >= pivot) high--; //
		A[low] = A[high]; // 比pivot小的元素到左边
		while(low < high && A[low] <= pivot) low++;
		A[high] = A[low]; // 比pivot大的元素到右边
	}
	A[low] = pivot; // 确定pivot的位置
	return low; // 返回pivot的位置
}

// 快排
int QuickSort(int A[], int low, int high){
	if(low < high){ // 递归跳出的条件
		int pivot_pos = Partition(A, low, high); // 划分
		QuickSort(A, low, pivot_pos - 1); // 快排左边
		QuickSort(A, pivot_pos + 1, high); // 快排右边
	}
}
```
## 效率分析
- 空间复杂度：O(递归层数)
- 时间复杂度：O(n*递归层数)
- 递归层数：
	- 最好：log2n
	- 最坏：n
- 稳定性：不稳定
---
# 简单选择排序
- 每一趟在待排元素中选择关键字最小的元素加入有序子序列。
- 代码实现
```C
void SelectSort(int A[], int n){
	for(int i = 0; i < n; i++){
		int min = i; // 认为第一个元素最小
		for(int j = i + 1; j < n; j++)
			if(A[j] < A[min]) min = j; // 找到了更小的元素替代
		if(min!=i) swap(A[i], A[min]);
	}
}
```
## 效率分析
- 空间复杂度：O(1)
- 时间复杂度：O(n^2)
- 稳定性：不稳定
---
# 堆排序
- 基于堆的排序
## 什么是堆
- 顺序存储的完全二叉树
	- ![](http://oss.pyaxy.xyz/img/20251208174416872.png)
	- 大根堆：根 >= 左、右
	- 小根堆：根 <= 左、右
- 要是可以把数组建立为大根堆，每次只需要取顶就可以直接取到最大的数了，简化了选择排序寻找的过程
## 建立大根堆
- 思路：把所有非终端节点（非终端节点编号$i<=\lfloor n/2 \rfloor$）都检查一遍，是否满足大根堆的要求，如果不满足，则进行调整。
	- 检查当前节点是否满足根 >= 左、右，**若不满足，则将当前节点与更大的一个孩子交换**。若交换破坏了下面层的堆，则采用相同的方法继续向下调整（**小元素不断下坠**）。
- 代码实现
```C
// 建立大根堆
void BuildMaxHeap(int A[], int len){
	for(int i = len/2; i > 0; i--) // 检查所有非终端节点
		HeadAdjust(A, i, len);
}
// 将以k为根的子树调整为大根堆
void HeadAdjust(int A[], int k, int len){
	A[0] = A[k]; // A[0]暂存子树的根节点
	for(int i = 2*k; i <= len; i *= 2){ // 沿着key较大的子结点向下
		if(i < len && A[i] < A[i + 1])
			i++; // 找到k的左右孩子里最大的一个
		if(A[0] >= A[i]) break; // 向下结束
		else{
			A[k] = A[i]; // 大的值向上
			k = i; // 修改k值，继续向下
		}
	}
	A[k] = A[0]; // 找到了适合k放的地方
}
```
## 基于大根堆的排序
- 堆排序：每一趟将堆顶元素加入有序子序列（与待排序序列最后一个元素进行交换，这样最大的值就在最后了）
	- 再将**待排序元素序列**调整为大根堆
```C
void HeapSort(int A[], int n){
	BuildMaxHeap(A, n); // 建立堆
	for(int i = n; i > 1; i--){ // n-1趟交换和建堆过程
		swap(A[i], A[1]); // 堆顶元素与堆底元素交换
		HeadAdjust(A, 1, i-1); // 把剩余的待排序元素整理为堆
	}
}
```
## 效率分析
- 建堆过程中，关键字对比次数不超过4n，时间复杂度为O(n)
- 总时间复杂度为O(nlog2n)
- 空间复杂度为O(1)
- 稳定性：不稳定
## 堆的插入删除
- 对于小根堆，新元素放到表尾，与父结点进行对比，若**新元素**比**父结点**更小，则将二者互换。新元素就这样**一路上升**。
- 对于小根堆，将表尾的元素替换被删除的元素，然后让该元素**一路下降**。
# 归并算法
- 归并：把两个或多个有序的序列合并为一个。
- 2路归并：把两个有序的序列合并为一个。
	- 2路归并选出小的一个元素需要对比1次
- n路归并：把n个有序的序列合并为一个。
	- **n路归并选出小的一个元素需要对比n-1次**
- 核心操作：把两个有序的子序列归并为一个
- 归并代码
```C
int *B = (int*)malloc(sizeof(int) * n); // 辅助数组B

// mid 将数组分为两个部分
void Merge(int A[], int low, int mid, int high){
	int i, j, k;
	for(k = low; k<=high; k++)
		B[k] = A[k]; // A的元素复制到B
	for(i = low, j = mid + 1, k = i;i <= mid && j <= high; k++){
		if(B[i] <= B[j])
			A[k] = B[i++]; // 较小值复制到A中
		else
			A[k] = B[j++];
	}//endfor
	while(i<=mid) A[k++] = B[i++]; // 检查剩下的
	while(j<=high) A[k++] = B[j++]; // 检查剩下的
}

void MergeSort(int A[], int low, int high){
	if(low < high){
		int mid = (low+high)/2; // 从中间划分
		MergeSort(A, low, mid); // 左边归并
		MergeSort(A, mid+1, high); // 右边归并
		Merge(A, low, mid, high); // 归并
	}
}
```

## 效率分析
- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)，主要来源于数组B
- 稳定性：稳定
---
# 基数排序（Radix Sort）
- 按照关键字的位划分排序
- 思路：设关键字为r进制的，那么设置r个辅助队列，每个队列存储元素
	- ![](http://oss.pyaxy.xyz/img/20251208200028536.png)
	- ![](http://oss.pyaxy.xyz/img/20251208200047807.png)
	- 第一趟收集结束后：得到了按**“个位”递减**排序的序列
	- ![](http://oss.pyaxy.xyz/img/20251208200137281.png)
	- ![](http://oss.pyaxy.xyz/img/20251208200149838.png)
	- 第二趟收集结束后：得到了按**“十位”递减**排序的序列，**“十位”相同的按“个位”递减**排序。
	- ![](http://oss.pyaxy.xyz/img/20251208200317779.png)
	- ![](http://oss.pyaxy.xyz/img/20251208200329822.png)
	- 第三趟收集结束后：得到了按**“百位”递减**排序的序列，**“百位”相同的按“十位”递减**排序，**“十位”相同的按“个位”递减**排序。
- ![](http://oss.pyaxy.xyz/img/20251208200430982.png)
## 效率分析
- 需要r个辅助队列，空间复杂度 = O(r)
- 一趟分配跑n次，一次收集跑r次，共需要d趟，时间复杂度 = O(d*(n+r))
- 稳定性：稳定
## 应用
- ![](http://oss.pyaxy.xyz/img/20251208200907760.png)
- ![](http://oss.pyaxy.xyz/img/20251208201130941.png)
# 记数排序
- 思想：就是在排序关键字元素取值范围较小情况下将每个数映射到数组里，然后记住每个元素出现了几次，再计算前缀和，就算出了每个元素的位置。
- ![](http://oss.pyaxy.xyz/img/20251208201927527.png)
- 从后往前（保证算法是稳定的）进行排序
	- ![](http://oss.pyaxy.xyz/img/20251208202146805.png)
- 代码：
```C
void CountSort(int A[], int B[], int n, int k){
	int i, C[k];    // 辅助数组C的长度取决于待排序元素取值范围0~k
	for(int i = 0; i < k; i++)
		C[i] = 0; // 初始化
	for(int i = 0; i < n; i++)
		C[A[i]] += 1; // 遍历待排序数组，统计每个关键字出现的次数
	for(int i = 1; i < n; i++)
		C[i] += C[i - 1]; // 再处理辅助数组，计算前缀和，统计每个数出现的位置
	for(int i = n - 1; i >= 0; i--){
		C[A[i]] -= 1;
		B[C[A[i]]] = A[i]; // 将元素Ai放到B中
	}
}
```

## 效率分析
- 空间复杂度 = O(n+k)
- 时间复杂度 = O(n+k)
	- 当k的数量级与n相等时，此时记数排序的**时间复杂度优于快排**等。
	- 当k>O(nlogn)，此时记数排序的**时间复杂度不如快排**等。
	- 典型的空间换时间的思想
---
# 外部排序
## 外存与内存的数据交换
- ![](http://oss.pyaxy.xyz/img/20251208205441147.png)
## 外部排序原理
- ![](http://oss.pyaxy.xyz/img/20251208205512753.png)
- 构成初始归并段
	- “归并排序”要求各个⼦序列有序，每次读⼊两个块的内容，进⾏内部排序后写回磁盘。得到一个有序的归并段
		- ![](http://oss.pyaxy.xyz/img/20251208211403796.png)
- 第一趟归并：
	- ![](http://oss.pyaxy.xyz/img/20251208211459056.png)
	- ![](http://oss.pyaxy.xyz/img/20251208211517892.png)
	- ![](http://oss.pyaxy.xyz/img/20251208211535395.png)
- 第二趟归并：
	- ![](http://oss.pyaxy.xyz/img/20251208211551409.png)
	- ![](http://oss.pyaxy.xyz/img/20251208211608216.png)
- 第三趟归并：
	- ![](http://oss.pyaxy.xyz/img/20251208211626812.png)
- ![](http://oss.pyaxy.xyz/img/20251208211644560.png)
## 如何优化外部排序
- 使用多路归并
	- ![](http://oss.pyaxy.xyz/img/20251208211754747.png)
	- 我们采用多路归并减少归并的趟数，从而减少磁盘IO次数
	- 对于r个初始归并段，做k路归并，则归并树可以用k叉树表示，若树高h，则归并趟数为$h-1=\lceil log_kr \rceil$，其中k越大，r越小，归并趟数就越少。
	- 缺点：
		- 内存开销增大
		- k路归并时，挑选一个关键字需要对比k-1次。
- 减少初始段数量
	- 生成初始段的“内存工作区”越大，初始段就越长，数量也就越少
- k路平衡归并
	1. 最多只能k个段归并为一个
	2. 每一趟归并中，若有m个段参加，则要得到$\lceil m/k \rceil$个新段
---
# 败者树
- 目的：k路归并时，挑选一个关键字需要对比k-1次，败者树可以减少这个次数
- 败者树——可视为⼀棵完全⼆叉树（多了⼀个头头）。k个叶结点分别是当前参加⽐较的元素，⾮叶⼦结点⽤来记忆左右⼦树中的“失败者”，⽽让胜者往上继续进⾏⽐较，⼀直到根结点。
	- ![](http://oss.pyaxy.xyz/img/20251208213654390.png)
- 在多路平衡归并中的应用
	- ![](http://oss.pyaxy.xyz/img/20251208213736106.png)
	- 有了败者树，选出最小元素只需对比关键字$\lceil log_2k \rceil$次
	- ![](http://oss.pyaxy.xyz/img/20251208213858969.png)
---
# 置换-选择排序
- 用于构造更长的初始归并段
- 工作方法：
	- ![](http://oss.pyaxy.xyz/img/20251208215949401.png)
	- ![](http://oss.pyaxy.xyz/img/20251208220002332.png)
	- ![](http://oss.pyaxy.xyz/img/20251208220021070.png)
	- ![](http://oss.pyaxy.xyz/img/20251208220032082.png)
	- 当工作区内的最小值不能放到归并段的末位时，锁定这个位置
	- ![](http://oss.pyaxy.xyz/img/20251208220047591.png)
	- ![](http://oss.pyaxy.xyz/img/20251208220130403.png)
	- ![](http://oss.pyaxy.xyz/img/20251208220141361.png)
	- 同理
	- ![](http://oss.pyaxy.xyz/img/20251208220201506.png)
	- 我们发现，最后生成的初始归并段的长度并不唯一。
---
# 最佳归并树
- 当置换选择排序生成的归并段长度不唯一时，不同的归并策略也会影响磁盘IO次数。
	- ![](http://oss.pyaxy.xyz/img/20251208220337971.png)
	- ![](http://oss.pyaxy.xyz/img/20251208220350565.png)
- 多路归并时
	- ![](http://oss.pyaxy.xyz/img/20251208220406933.png)
	- ![](http://oss.pyaxy.xyz/img/20251208220426451.png)
	- 当初始归并段的数量不足以形成最佳归并树时，需要几个添加长度为0的虚拟归并段
		- ![](http://oss.pyaxy.xyz/img/20251208220530482.png)
	- 添加的虚段的数量：
		- ![](http://oss.pyaxy.xyz/img/20251208220604246.png)