# 串的定义
- 串，string，由零个或多个字符组成的有限序列。
	- `S='a1a2···an'`
		- S为串名，字符个数n为串的长度
	- 子串：==串中任意**连续的**字符组成的子序列==
	- 字符在主串中的位置：从1开始数。
	- 子串在主串中的位置：子串的第一个字符在主串中的位置。
---
# 串的基本操作
```C
StrAssign(&T, chars); // 赋值操作。把串T赋值为chars
StrCopy(&T, S); // 复制操作
StrEmpty(S); // 判空操作
StrLength(S); // 求串长
ClearString(&S); // 清空操作
DestoryString(&S); // 销毁操作
Concat(&T, S1, S2); // 拼接操作 T = S1 + S2
SubString(&Sub, S, pos, len); // 取子串
Index(S, T); // 定位操作，在主串S中寻找与T相同的子串，返回位置
StrCompare(S, T); // 比较操作
```
# 串的存储结构
## 串的顺序存储
- 静态数组实现
```C
#define MAXLEN 255
typedef struct{
	char ch[MAXLEN];
	int length;
}SString;
```
- 动态数组实现
```C
typedef struct{
	char *ch;
	int length;
}DString;
DString S;
S.ch = (char*)malloc(MAXLEN * sizeof(char));
S.length = 0;
```
- 串的实际长度只能小于等于MAXLEN，可以采用length字段或者`\0`符号来控制串的长度，我们默认访问字符串从ch\[1]开始。
---
## 串的链式存储
- 普通链式存储
```C
typedef struct StringNode{
	char ch;
	struct StringNode *next;
}StringNode, *String;
```
- ![](http://oss.pyaxy.xyz/img/20250720204514743.png)
- 缺点：存储密度低
- 解决方法：块链存储
```C
typedef struct StringNode{
	char ch[4];
	struct StringNode *next;
}StringNode, *String;
```
- ![](http://oss.pyaxy.xyz/img/20250720204606572.png)
- 最后一个节点不满时使用`#`填充。
#  串的模式匹配
> [!info]
> 字符串的模式匹配：在主串中寻找与模式串相同的子串，并返回其所在位置。
## 朴素模式匹配
- 思想：暴力搜
- ![](http://oss.pyaxy.xyz/img/20250720210236666.png)
- 算法：将主串中==所有长度为m的子串==（有n-m+1个子串）依次与模式串进行对比，直到找到一个完全匹配的字符串，或没有一个匹配的。
- 使用基本操作：
```C
int index(SString S, SString T){
	int i = 1, n = StrLength(S), m = StrLength(T);
	SString Sub;
	while(i <= n - m + 1){
		SubString(sub, S, i, m);
		if(StrCompare(sub, T) != 0) ++i;
		else return i;
	}
	return 0;
}
```
---
- 不使用基本操作
```C
int index(SString S, SString T){
	int i = 1, j = 1;
	while(i <= S.length && j <= T.length){
		if (S.ch[i] == T.ch[j])
			i++;j++; // 继续比较后续字符
		else
			i = i - j + 2;j=1;
	}
	if (j > T.length) return i - T.length;
	return 0;
}
```
- 最坏时间复杂度：$O(nm)$
---
## KMP算法
> [!question]
> 朴素匹配算法的问题：每次前进m步，又往回退m-1步，需要想办法解决回退m-1步的问题。

### 思想：尝试只让模式串指针回溯，主串指针不回溯。
- 前缀：==除最后一个字符外==，字符串的所有头部子串；后缀：==除第一个字符外==，字符串的所有尾部子串。
- 若**已匹配的k个字符中的有一部分后缀为模式串的前缀，那么我们可以把模式串的这部分前缀与该后缀对齐**，因为两者相等，不需要再继续比较，直接继续比较后面的位置就行，我们可以使用next数组来记录长度为m的模式串中，当第1～m个字符不匹配时下一个需要比较的位置（手算计算next数组）
- e.g. 模式串为google
	- next数组如下所示
	- ![](http://oss.pyaxy.xyz/img/20250720214501927.png)
	- 当j=1时，如果匹配不成功，那么我们可以直接i++，j++看下一个主串的字符。为了便于代码编写，我们把j=1匹配失败时j的值设为0，如何再进行上面的j++之后即可继续从模式串的第1个字符开始匹配。
	- 当j=2时，如果匹配不成功，那么我们已匹配的字符串为`g`，其后缀为空集，则继续从模式串头开始匹配。
	- 当j=3时，如果匹配不成功，那么我们已匹配的字符串为`go`，其所有后缀`o`都没有和模式串的前缀匹配的串，则继续从模式串头开始匹配。
	- 当j=4时，如果匹配不成功，那么我们已匹配的字符串为`goo`，其所有后缀`oo`、`o`都没有和模式串的前缀匹配的串，则继续从模式串头开始匹配。
	- 当j=5时，如果匹配不成功，那么我们已匹配的字符串为`goog`，其所有后缀`oog`、`og`、`g`可以和模式串的一个前缀`g`匹配上，那么当我们匹配`goog?`中的`?`时，我们可以直接匹配模式串中的`g(o)ogle`，即模式串的第二个字符，第一个字符已经根据前后缀匹配相等了，不需要再进行匹配。
- 使用next数组进行实现KMP算法
```C
int KMP(SString S, SString T, int next[]){
	int i = 1, j = 1;
	while(i <= S.length && j <= T.length){
		// 模式串第一个字符匹配失败或匹配成功时主串指针才向后移动
		if(j == 0 || S.ch[i] == T.ch[j]){
			i++;j++;
		}
		else{
			j = next[j]; // 模式串向右移动
		}
	}
	if(j > T.length) return i - T.length;
	return 0;
}
```
- 时间复杂度：$O(m+n)$
### 手算next数组
- 当第j个字符匹配失败，由1~j-1个字符组成的串记为S，则
$$next[j]=S的最长相等前后缀长度+1$$
- 如图：
- ![](http://oss.pyaxy.xyz/img/20250720221242437.png)
- `S=ababab`则最长相等前后缀为`abab`，则下一个匹配的位置为这个串的后一个位置，即`next[7]=5`。
- 特别的`next[1]=0,next[2]=1`。
---
### KMP算法的进一步优化
求nextval数组：
```C
nextval[1] = 0;
for(int i = 2; i <= T.length; i++) {
	if (T.ch[next[i]] == T.ch[i])
		nextval[i] = nextval[next[i]];
	else
		nextval[i] = next[i];
}
```
- 当j指向的元素与next\[j]指向的元素一样时，nextval\[j]=nextval\[next\[j]]，否则与next\[j]一样