# 图的基本概念
- **图G（graph）**由**顶点集V（vertex）**和**边集E（edge）**组成，记为G = (V, E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V = {v1, v2, … , vn}，则用|V|表示图G中顶点的个数，也称图G的阶，E = {(u, v)}，用|E|表示图G中边的条数。
- ![](http://oss.pyaxy.xyz/img/20250818170912009.png)

> [!note]
> 注意：线性表可以是空表，树可以是空树，但图不可以是空，即**V一定是非空集**


---
## 无向图、有向图
- 
- 若E是**无向边**（简称**边**）的有限集合时，则图G为**无向图**。边是顶点的无序对，**记为(v, w)或(w, v)**，因为==(v, w) = (w, v)==，其中v、w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w)依附于顶点w和v，或者说边(v, w)和顶点v、w相关联。
	- ![](http://oss.pyaxy.xyz/img/20250818171134180.png)
- 若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是顶点的有序对，记为<v, w>，其中v、w是顶点，v称为弧尾，w称为弧头，<v, w>称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。<v, w> ≠ <w, v>。
	- ![](http://oss.pyaxy.xyz/img/20250818171143980.png)
---
## 简单图、多重图
- 简单图：
	1. 不存在重复边
	2. 不存在自己连自己的边。
	3. **本课程只讨论简单图**
	4. ![](http://oss.pyaxy.xyz/img/20250818171345806.png)
- 多重图
	- 与简单图对应的图。
	- ![](http://oss.pyaxy.xyz/img/20250818171331927.png)
---
## 顶点的度、入度、出度
- 对于==无向图==：**顶点的度**是指依附于该顶点的边的条数记为TD(v)。
	- 在具有n个顶点、e条边的无向图中，$$\sum_{i=1}^{n}{TD(v_i)}=2e$$即无向图的全部顶点的度的和等于边数的2倍（每条边贡献2个度）。
- 对于==有向图==：
	- **入度**是以顶点v为终点的有向边的数目，记为ID(v)；
	- **出度**是以顶点v为起点的有向边的数目，记为OD(v)。
	- **顶点v的度**等于其入度和出度之和，即TD(v) = ID(v) + OD(v)。
	- 在具有n个顶点、e条边的有向图中，$$\sum_{i=1}^{n}{ID(v_i)} = \sum_{i=1}^{n}{OD(v_i)} = e$$
---
## 顶点-顶点关系描述
- 路径——顶点vp到顶点vq之间的一条路径是指顶点序列，V1,V2,V3...,V6
- 回路——第一个顶点和最后一个顶点相同的路径称为回路或环
- 简单路径——在路径序列中，顶点不重复出现的路径称为简单路径。
- 简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。
- 路径长度——路径上边的数目
- 点到点的距离——从顶点u出发到顶点v的==最短路径==若存在，则==此路径的长度称为从u到v的距离==。若从u到v根本不存在路径，则记该距离为无穷（∞）。
- 无向图中，若从顶点v到顶点w有路径存在，则称v和w是**连通**的
- 有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是**强连通**的
---
## 连通图、强连通图
- ![](http://oss.pyaxy.xyz/img/20250818172404923.png)
- 若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。
	- 连通图的常见考点 #常考 
		- 对于n个顶点的无向图G
		- 若为==连通图==，则==最少==有n-1条边
		- 若为==非连通图==，则==最多==$C_{n-1}^{2}$条边（孤立一个点，剩下的顶点两两相连）
		- 注意： #易错点 
			- 一个n个顶点n条边的图不一定是连通图，因为可以拿出其中n-1个顶点把n条边填进去剩下的一个顶点孤立。==但他一定有环==。
			- 一个有n个结点的图无论怎么都是连通图的情况为`e>(n-1)(n-2)/2`，拿出n-1个结点填满边，只要再多一条边就怎么都是连通的了。
- ![](http://oss.pyaxy.xyz/img/20250818172704684.png)
- 若图中任何一对顶点都是强连通的，则称此图为强连通图。
	- 强连通图的常见考点 #常考 
		- 对于n个顶点的有向图G
		- 若G是==强连通图==，则==最少==有n条边（形成回路）

> [!note]
> 注意：连通图是在无向图的范畴中，强连通图是在有向图的范畴中。

---
## 子图
- ![](http://oss.pyaxy.xyz/img/20250818173144495.png)
- 设有两个图G = (V, E)和G' = (V', E')，若V'是V的子集，且E'是E的子集，则称G'是G的**子图**。
- 若有满足V(G¢) = V(G)的子图G¢，则称其为G的**生成子图**（保留所有顶点）。
>[!note]
>并非挑出任意几条边、几个顶点就可以构成子图
>![](http://oss.pyaxy.xyz/img/20250818173229840.png)
---
## 连通分量
- **无向图**中的==**极大连通子图**==称为==连通分量==
	- 子图必须连通，且包含尽可能多的顶点和边。
- ![](http://oss.pyaxy.xyz/img/20250818190236606.png)
---
## 强连通分量
- **有向图**中的==极大强连通子图==称为有向图的==强连通分量==
	- 子图必须强连通，同时包含尽可能多的顶点和边
- ![](http://oss.pyaxy.xyz/img/20250818190357785.png)
---
## 生成树
- ==连通图==的**生成树**是==包含图中全部顶点的一个**极小连通子图**（边的数量尽可能少）==。
	- 若图有n个顶点，则他的生成树有n-1条边（相当于一棵树中有n-1度）。对于生成树而言：删除一条边会让其变成非连通图；增加一条边会让其形成一个回路
- ![](http://oss.pyaxy.xyz/img/20250818190705148.png)
---
## 生成森林
- 在==非连通图==中，其==连通分量的生成树==构成了非连通图的**生成森林**。
- ![](http://oss.pyaxy.xyz/img/20250818190757730.png)
---
## 边的权、带权图/网
- 边的权——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的**权值**。
- 带权图/网——边上带有权值的图称为**带权图**，也称**网**。
- 带权路径长度——当图是带权图时，**一条路径上所有边的权值之和**，称为该路径的带权路径长度
- e.g.
	- ![](http://oss.pyaxy.xyz/img/20250818191002964.png)
## 几种特殊的图
- **无向完全**图：无向图中任意两个顶点之间都有边
	- n个顶点的无向完全图有`n(n-1)/2`条边
- **有向完全图**：有向图中任意两个顶点之间都有两条方向相反的**弧**
	- n个顶点的有向完全图有`n(n-1)`条边
- **稀疏图**：边很少的图，一般认为`E<VlogV`为稀疏图
- **稠密图**：边很多的图
- **树**：==不存在回路==，且**连通**的无向图
	- #常考 n个顶点的树，必有n-1条边；则n个顶点的图，当边数大于n-1时一定有回路
- **有向树**：1个顶点的入度为0（根结点），其余顶点的入度均为1的有向图。
---
# 图的存储
## 邻接矩阵法
- ![](http://oss.pyaxy.xyz/img/20250822183751211.png)
- 对于无向图：
	- 邻接矩阵G\[A]\[B]=1表示AB之间有边
	- 第i个结点的**度**=**第i行（或第i列）**的非零元素个数
- 对于有向图：
	- 邻接矩阵G\[A]\[B]=1表示A->B之间有边
	- 第i个结点的**出度**=**第i行**的非零元素个数
	- 第i个结点的**入度**=**第i列**的非零元素个数
	- 第i个结点的**度**=**第i行、第i列**的非零元素个数之和_
- 邻接矩阵法求顶点的度/入度/出度的时间复杂度为$O(|V|)$
- 邻接矩阵的代码定义
```C
#define MaxVertexNum 100
typedef struct{
	char Vex[MaxVertexNum]; // 顶点表
	int Edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵、边表
	int vexnum,arcnum // 图当前的顶点数与边数/弧数
}MGraph;
```
---
- 邻接矩阵存储带权图
- ![](http://oss.pyaxy.xyz/img/20250822184328939.png)
	- 邻接矩阵中的数值存储边的权重。我们认为**权重为∞表示两个顶点不可达**。
- 邻接矩阵存储带权图代码定义
```C
#define MaxVertexNum 100
#define INFINITY 最大的int值
typedef struct{
	char Vex[MaxVertexNum]; // 顶点表
	int Edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵、边表
	int vexnum,arcnum // 图当前的顶点数与边数/弧数
}MGraph;
```
---
- 邻接矩阵法的性能分析
	- 空间复杂度：$O(|V|^2)$。只与顶点数有关。
	- 适合存储**稠密图**。
	- 无向图的邻接矩阵是对称矩阵，可以压缩存储。
	- ![](http://oss.pyaxy.xyz/img/20250822184742821.png)
---
- 邻接矩阵法的性质
	- 设图G的邻接矩阵为A（矩阵元素为0/1），则$A^n$的元素A^n\[i]\[j]等于由顶点i到顶点j的长度为n的路径的数目。
	- ![](http://oss.pyaxy.xyz/img/20250822184907163.png)
## 邻接表法
- 由于数组实现的邻接矩阵法空间复杂度高，不适合存储稀疏图，我们使用顺序+链式存储方式存储图，即**邻接表法**。
- ![](http://oss.pyaxy.xyz/img/20250822185043207.png)
- 邻接表法的代码实现
```C
// 顶点
typedef struct VNode{
	VertexType data;
	ArcNode *first;
}VNode,AdjList[MaxVertexNum];

// 边
typedef struct ArcNode{
	int adjvex; // 边指向哪个顶点
	struct ArcNode *next; // 指向下一弧的指针。
	int weight; // 权重
}ArcNode;

// 图
typedef struct{
	AdjList vertices;
	int vexnum,arcnum;
}ALGraph;
```
- 对于无向图
	- 边结点的数量是2|E|，整体空间复杂度为O(|V| + 2|E|)
- 对于有向图
	- 边结点的数量是|E|，整体空间复杂度为O(|V| + |E|)
- 只要确定了顶点编号，图的邻接矩阵表示方式唯一。但图的邻接矩阵表示方式不唯一。
---
## 十字链表法
>[!info]
>当使用邻接矩阵法和邻接表法存储**有向图**时：**邻接矩阵**空间复杂度**较高**；**邻接表**找**顶点的入边**不方便，因此我们引入了十字链表法。

- ==十字链表法用于存储**有向图**。==
- ![](http://oss.pyaxy.xyz/img/20250822190034088.png)
- 空间复杂度：$O(|V|+|E|)$
- 如何在十字链表中找到一个结点的所有**出边**：沿着**绿色**的路线找。
- 如何在十字链表中找到一个结点的所有**入边**：沿着**橙色**的路线找。
---
## 邻接多重表法
>[!info]
>当使用邻接矩阵法和邻接表法存储**无向图**时：**邻接矩阵**空间复杂度**较高**；**邻接表**每条边对应两份冗余信息，删顶点/边等操作时间复杂度高，因此我们引入了邻接多重表。

- - ==邻接多重表法用于存储**无向图**。==
- ![](http://oss.pyaxy.xyz/img/20250822190918295.png)
- 邻接多重表法每条边只有一份数据，因此空间复杂度为$O(|E|+|V|)$
- 删除边、删除结点等操作很方便。
---
## 上面几种存储方式等优缺点
- ![](http://oss.pyaxy.xyz/img/20250822191136283.png)
---
## 图的基本操作
- Adjacent(G,x,y)：判断图G是否存在边<x, y>或(x, y)。
- Neighbors(G,x)：列出图G中与结点x邻接的边。
- InsertVertex(G,x)：在图G中插入顶点x。
- DeleteVertex(G,x)：从图G中删除顶点x。
- AddEdge(G,x,y)：若无向边(x, y)或有向边<x, y>不存在，则向图G中添加该边。
- RemoveEdge(G,x,y)：若无向边(x, y)或有向边<x, y>存在，则从图G中删除该边。
- ==FirstNeighbor(G,x)==：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
- ==NextNeighbor(G,x,y)==：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。
- Get_edge_value(G,x,y)：获取图G中边(x, y)或<x, y>对应的权值。
- Set_edge_value(G,x,y,v)：设置图G中边(x, y)或<x, y>对应的权值为v。
- 还有==图的遍历算法==，包括深度优先和广度优先。
---
### 时间复杂度分析
#### Adjacent(G,x,y)
- 判断图G是否存在边<x, y>或(x, y)。
- 对于无向图：
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)~O(|V|)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)~O(|V|)
#### Neighbors(G,x)
- 列出图G中与结点x邻接的边。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(|V|)
	- 邻接表的时间复杂度：O(1)~O(|V|)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(|V|)
	- 邻接表的时间复杂度：求出边：O(1)~O(|V|)；求入边：O(|E|)
#### InsertVertex(G,x)
- 在图G中插入顶点x。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)
#### DeleteVertex(G,x)
- 从图G中删除顶点x。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(|V|)
	- 邻接表的时间复杂度：O(1)~O(|E|)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(|V|)
	- 邻接表的时间复杂度：删出边：O(1)~O(|V|)；删入边：O(|E|)
#### AddEdge(G,x,y)
- 若无向边(x, y)或有向边<x, y>不存在，则向图G中添加该边。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)
#### RemoveEdge(G,x,y)
- 若无向边(x, y)或有向边<x, y>存在，则从图G中删除该边。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)~O(|V|)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)~O(|V|)
#### FirstNeighbor(G,x)
- 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)~O(|V|)
	- 邻接表的时间复杂度：O(1)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)~O(|V|)
	- 邻接表的时间复杂度：出边邻接点：O(1)；入边邻接点：O(1)~O(|E|)
####  NextNeighbor(G,x,y)
- 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)~O(|V|)
	- 邻接表的时间复杂度：O(1)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)~O(|V|)
	- 邻接表的时间复杂度：出边邻接点：O(1)；入边邻接点：O(1)~O(|E|)
#### Get_edge_value(G,x,y)
- 获取图G中边(x, y)或<x, y>对应的权值。
- 其时间复杂度与[[图#Adjacent(G,x,y)]]雷同，核心都在于找到对应的边。
#### Set_edge_value(G,x,y,v)
- 设置图G中边(x, y)或<x, y>对应的权值为v。
- 其时间复杂度与[[图#Adjacent(G,x,y)]]雷同，核心都在于找到对应的边。
---
# 图的遍历
## 广度优先遍历（BFS）
- ⼴度优先遍历（Breadth-First-Search,BFS）要点：
	1. 找到与⼀个顶点相邻的所有顶点
	2. 标记哪些顶点被访问过
	3. 需要⼀个辅助队列
- ==FirstNeighbor(G,x)==：求图G中顶点x的第⼀个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
- ==NextNeighbor(G,x,y)==：假设图G中顶点y是顶点x的⼀个邻接点，返回除y之外顶点x的下⼀个邻接点的顶点号，若y是x的最后⼀个邻接点，则返回-1。
- 代码实现
```C
bool visited[MAX_VERTEX_NUM]; // 访问标记数组，初始为false

void BFSTraverse(Graph G){ // 对图G进行BFS遍历
	for(int i = 0; i < G.vexnum; i++)
		visited[i]=false; // 初始化标记数组
	InitQueue(Q); // 初始化队列
	for(int i = 0; i < G.vexnum; i++){ // 从 0 开始遍历
		if(!visited[i]) // 对每个连通分量进行 BFS
			BFS(G, i);
	}
}
// 从v出发进行BFS
void BFS(Graph G, int v){
	visit(v);
	visited[v] = true;
	EnQueue(Q, v);
	while(!isEmpty(Q)){
		DeQueue(Q, v);
		for(w = FirstNeighbor(G, v); w>=0; w = NextNeighbor(G, v, w))
		// 遍历所有邻接点
		if(!visited[w]){ // w未访问	
			visit(w); // 访问顶点w
			visited[w] = true; // 标记为已访问
			EnQueue(Q, w); // 顶点w入队
		}
	}
}
```
> [!note]
> 如果是非连通图，则需要在BFSTraverse函数中把每个没有访问过的顶点进行BFS遍历。因此==对于无向图，调用BFS的次数=连通分量数==

---
### 复杂度分析
- 空间复杂度：最坏情况下起始顶点与其他每个都相连，辅助队列大小为O(|V|)
- 时间复杂度分析：
	- 核心思想：访问每个顶点的时间+访问每个顶点的邻接点的时间
	- 对于**邻接矩阵**存储的图：访问n个顶点需要O(n)时间，每个顶点的邻接点访问都需要O(n)时间。**时间复杂度=$O(n^2)$**
	- 对于**邻接表**存储的图：访问n个结点需要O(n)时间，查找各个顶点的邻接点共需要O(e)时间。**时间复杂度=$O(n+e)$**
### 广度优先生成树
- 在广度优先遍历的过程中，除了BFS起始结点外，每个结点都有唯一一个前驱访问结点，因此将遍历过程走过的边保留即可得到广度优先生成树。
- ⼴度优先⽣成树由⼴度优先遍历过程确定。
	- 同⼀个图的**邻接矩阵**表示⽅式**唯⼀**，因此⼴度优先**遍历序列唯⼀**，广度优先**生成树也唯一**
	- 同⼀个图**邻接表**表示⽅式**不唯⼀**，因此⼴度优先**遍历序列不唯⼀**，广度优先**生成树也不唯一**
- 对于非连通图的广度优先遍历，可得到广度优先生成森林。
	- ![](http://oss.pyaxy.xyz/img/20250822212115444.png)
## 深度优先遍历（DFS）
- 与树的[[树与二叉树#先根遍历]]类似。
- 代码实现：
```C
bool visited[MAX_VERTEX_NUM]; // 访问标记数组
void DFSTraverse(Graph G){ // 对图G进行DFS遍历
	for(int i = 0; i < G.vexnum; i++)
		visited[i]=false; // 初始化标记数组
	for(int i = 0; i < G.vexnum; i++){ // 从 0 开始遍历
		if(!visited[i]) // 对每个连通分量进行 DFS
			DFS(G, i);
	}
}

// 从v出发，对图G进行DFS
void DFS(Graph G, int v){
	visit(v); // 访问v
	visited[v] = true; // 标记为已访问
	// v的邻接点w们
	for(w = FirstNeighbor(G,v); w>=0; w = NextNeighbor(G,v,w)){
		if(!visited[w]) // w未被访问
			DFS(G, w);
	}
}
```
- **深度优先遍历可以判断图中是否有环（回路）**
### 复杂度分析
- 空间复杂度：来⾃函数调⽤栈，**最坏情况，递归深度为O(|V|)；最好情况，递归深度为O(1)**
- 时间复杂度：
	- 核心思想：访问各结点所需时间+探索各条边所需时间
	- **邻接矩阵**存的图：访问 |V| 个顶点需要O(|V|)的时间，查找每个顶点的邻接点都需要O(|V|)的时间，⽽总共有|V|个顶点。**时间复杂度=$O(|V|^2)$**
	- **邻接表**存的图：访问 |V| 个顶点需要O(|V|)的时间，查找各个顶点的邻接点共需要O(|E|)的时间。**时间复杂度=O(|V|+|E|)**
### 深度优先生成树
- 深度优先⽣成树由深度优先遍历过程确定。
	- 同⼀个图的**邻接矩阵**表示⽅式**唯⼀**，因此深度优先**遍历序列唯⼀**，深度优先**生成树也唯一**
	- 同⼀个图**邻接表**表示⽅式**不唯⼀**，因此深度优先**遍历序列不唯⼀**，深度优先**生成树也不唯一**
- 对于非连通图的深度优先遍历，可得到深度优先生成森林。
---
## 图的遍历与图的连通性分析
- 对**无向图**进行**BFS/DFS遍历**，调用**BFS/DFS**函数的次数=连通分量数。
	- 对于**连通图**，只需**调用一次**BFS/DFS。
- 对**有向图**进行**BFS/DFS遍历**
	- 若起始顶点到其他各顶点都有路径，则只需调⽤1次BFS/DFS 函数
	- 对于**强连通图**，从任⼀结点出发都只需调⽤1次 BFS/DFS函数
---
# 最小生成树
## 最小生成树的概念
- 连通图的[[图#生成树]]是包含图中全部顶点的一个极小连通子图。要求边尽可能少且保持连通。
- 对于⼀个**带权连通⽆向图**G = (V, E)，⽣成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中**边的权值之和最⼩的⽣成树**，则T称为G的**最⼩⽣成树（Minimum-Spanning-Tree, MST）。**
	- 最小生成树可能有多个，但边的权值和为最小且是唯一的。
	- 最小生成树的边数：最小生成树也是生成树，因此边数等于顶点数-1，少一条则不连通，多一条则会出现回路。
	- #易错点 如果一个连通图本身就是树（无向连通图有n-1条边），则其最小生成树就是本身，==因此唯一==。
	- #易错点 只要无向连通图中没有边权相等的边，则其最小生成树唯一（每次总选择边权最小的满足条件的边，因此每次选择的边、顶点总一致）
	- #易错点 若有n个顶点的无向连通图的最小生成树不唯一，则其边数一定大于n-1
	- 只有连通图才有生成树，非连通图只有生成森林。
---
## Prim算法生成最小生成树
- 算法过程：
	- ==从某⼀个顶点开始构建⽣成树；每次将代价最⼩的新顶点纳⼊⽣成树，直到所有顶点都纳⼊为⽌。==
- 时间复杂度：$O(|V|^2)$，因此适用于边稠密的图。
---
## Kruskal算法生成最小生成树
- 算法过程
	- 每次选择⼀条权值最⼩的边，使这条边的两头连通（原本已经连通的就不选）。
- 时间复杂度：$O(|E|log_2|E|)$，因此适用于边稀疏的图。
---
# 最短路径

>[!note]
>最短路径一定是简单路径
## BFS求无权图的单源最短路径
- 从起点u出发，其每层遍历出去距离都加一，因为是无权图，n到q有几层最短距离就是几。
- 辅助数组：
	- d\[i]：表示u到i的最短路径距离
	- path\[i]：表示u到i的最短路径中i的上一个顶点
- 代码实现，基于[[图#广度优先遍历（BFS）]]，在visit一个顶点时，修改其最短路径长度d\[]并在path\[]上记录前驱结点。
```C
// 求u到图G中其他顶点的最短路径
void BFS_MIN_Distance(Graph G, int u){
	// d[i]表示从u到i结点的最短路径
	for(int i = 0; i < G.vexnum; i++){
		d[i] = INFINITY;
		path[i] = -1;
	}
	d[u] = 0;
	visited[u] = true;
	EnQueue(Q, u);
	while(!isEmpty(Q)){ // 队列不空
		DeQueue(Q, u); // 队头元素u出队
		for(int w = FirstNeighbor(G, u); w>=0; w = NextNeighbor(G,u,w)){
			if(!visited[w]){ // u的所有未访问的邻接点
				d[w] = d[u] + 1; // 路径长度加1
				path[w] = u; // 更新路径
				visited[w] = true; // 标记已访问
				EnQueue(Q, w); // 入队
			}
		}
	}
}
```
- 由此可知，从u为起点的BFS遍历生成的==广度优先生成树一定是以u为根的，高度最小的生成树==。
---
## 迪杰斯特拉（Dijkstra）算法
- 由于BFS算法只适用于无权图（所有边权值相同的图），我们引入了Dijkstra算法**求单源最短路径**。
- 辅助数组：
	- final\[]：标记各个顶点是否已找到最短路径。
	- dist\[]：最短路径长度。
	- path\[]：路径上的前驱。
- 算法过程：
	- 初始化辅助数组，起点到起点的距离为0，填写起点到其邻接点的路径长度、路径前驱。
		- ![](http://oss.pyaxy.xyz/img/20250823144545296.png)
	- 循环遍历所有结点
		- 找到final\[]为false的所有结点中dist最小的结点i，其最短路径则已确定，令final\[i]=true。
			- 分析：因为假设起点到vi的距离为最短，则起点到其他结点的距离均大于这个最短路径，因此不存在其他结点中转另一结点到vi距离最短的路径（前提是没有负权边），==**因此Dijkstra算法只适用于非负权图。**==
		- 检查所有vi的邻接点j，如果其final\[j]值为false，则更新其dist\[j]为min{dist\[j], dist\[i] + weight\[i]\[j]}（即尝试以vi为中转结点求得更小的路径），若中转结点产生的路径更短，同步更新path。
- 时间复杂度分析：
	- 每次都要遍历1～n找到dist最小的值，再遍历vi的1～n邻接点，因此时间复杂度为$O(n^2)$
---
## 弗洛伊德（Floyd）算法
- Floyd算法：求每一对顶点之间的最短路径，且**可以计算负权图**，但不能解决带负权回路的图，这种图可能没有最短距离。
- 思想：动态规划
	- 对于n个顶点的图G，求任意⼀对顶点 Vi —> Vj 之间的最短路径可分为如下⼏个阶段：
		- 初始：不允许在其他顶点中转，最短路径是？
		- 0：若允许在 V0中转，最短路径是？
		- 1：若允许在 V0、V1中转，最短路径是？
		- 2：若允许在 V0、V1、V2中转，最短路径是？
		- 。。。
		- n-1：若允许在 V0、V1、V2 ……Vn-1中转，最短路径是？
- 初始化操作：
	- 辅助数组：
		- A\[]\[]：即图的邻接矩阵。
		- paht\[]\[]：最短路径上的前驱，初始为-1
- 代码实现
```C
// 初始化辅助数组
for(int k = 0; k < n; k++){ // 使用vk最为中转点
	for(int i = 0; i < n; i++){ // 更新每两个点之间使用vk作为中转点距离是否会更小
		for(int j = 0; j < n; j++){
			if(A[i][j] > A[i][k] + A[k][j]){ // 如果以 vk 中转距离更小
				A[i][j] = A[i][k] + A[k][j]; // 更新最短路径长度
				path[i][j] = k; // 更新路径
			}
		}
	}
}
```
- 时间复杂度分析：$O(n^3)$
---
## 对比3种最短距离算法
![](http://oss.pyaxy.xyz/img/20250823151204621.png)

---
# 有向无环图（DAG）
- **有向无环图**：若⼀个**有向图**中**不存在环**，则称为有向⽆环图，简称**DAG图**（Directed Acyclic Graph）。
	- ![](http://oss.pyaxy.xyz/img/20250823151333906.png)
## 使用DAG描述算术表达式
- 在使用树描述算术表达式时，会**出现重复部分**，如下图的红色部分与绿色部分，我们可以省略出算术表达式树中具有相同子树的部分，使其形成一个DAG图。
	- ![](http://oss.pyaxy.xyz/img/20250823151711124.png)
- 当我们把所有的公共子树消除掉只保留一个时，生成的DAG图如下。
	- ![](http://oss.pyaxy.xyz/img/20250823151750995.png)
- 由于所有的**公共子树消除掉只保留一个**，因此顶点中不可能出现重复的操作数，每个操作数只会出现一次，因此使用DAG图描述算术表达式的步骤如下。
	1. 把各个操作数不重复的拍成一排。
	2. 标出各个运算符的生效顺序（主要是优先级顺序，同等优先级无所谓）
	3. 按顺序加入运算符，注意==“分层”==，一个符号在其两个操作数的上层位置。
	4. 从底向上逐层检测**同层的运算符**是否可以合并。
---
# 拓扑排序
## AOV网
- **AOV⽹**(Activity On Vertex NetWork，⽤**顶点**表示活动的⽹)：
- **⽤DAG图（有向⽆环图）表示**⼀个⼯程。顶点表示活动，有向边<Vi, Vj>表示活动Vi必须先于活动Vj进⾏。
	- ![](http://oss.pyaxy.xyz/img/20250823152429428.png)
---
## 拓扑排序
- 拓扑排序：找到做事的先后次序。
- 实现：
	1. 从AOV网中选择一个没有前驱的（入度为0）的顶点并输出。
	2. 从网中删除该结点和其连接的有向边。
	3. 重复1和2直到当前**AOV网为空**或**当前网中不存在无前驱的顶点**（说明有回路）。
- **因此每个AOV网络都有1个或多个拓扑排序序列**。
- 代码实现：
	- 辅助数组：
		- indegree\[]：存储所有点的入度。
		- print\[]：记录拓扑排序序列
		- Stack\[]：保存目前找到的度为0的点
```C
bool TopologicalSort(Graph G){
	InitStack(S);
	for(int i = 0; i < G.vexnum; i++)
		if(indegree[i]==0)
			Push(S, i); // 将所有入度为0的顶点入栈
	int count = 0;
	while(!isEmpty(S)){ // 栈不空则存在度为0的结点
		Pop(S, i); // 栈顶出栈
		print[count++] = i; // 输出顶点i
		for(p=G.vertices[i].firstarc; p!=NULL; p=o->nextarc;){
		// i 指向的所有顶点入度减1
			v = p->adjvex;
			if(--indegree[i] == 0)
				Push(S, v); // 入度为0则入栈
		}
	}
	if(count<G.vexnum)
		return false; // 说明出现环路
	else
		return true; // 拓扑排序成功
}
```
---
## 逆拓扑排序
- 对⼀个AOV⽹，如果采⽤下列步骤进⾏排序，则称之为**逆拓扑排序**：
	1. 从AOV⽹中选择⼀个没有后继**（出度为0）**的顶点并输出。
	2. 从⽹中删除该顶点和所有以它为终点的有向边。
	3. 重复①和②直到当前的AOV⽹为空
- 其代码实现与拓扑排序类似，但是问题在于时间复杂度上，因为要**找到**一个结点的所有**入边**，需要**遍历整个邻接表**，因此我们可以考虑使用**逆邻接表**实现，即表中存的是该结点的入边。
- 当然我们也可以使用[[图#深度优先遍历（DFS）]]算法实现逆拓扑排序。
	- 思想：DFS停止循环的条件是该结点没有未访问过的邻接点，因此其没有后继（出度为0）
- 代码实现：
```C
void DFSTraverse(Graph G){ // 对图G进行深度优先遍历
	for(v=0; v<G.vexnum;v++)
		visited[v]=false; // 初始化标记数组
	for(v=0; v<G.vexnum;v++) // 从0开始遍历
		if(!visited[v])
			DFS(G, v);
}

void DFS(Graph G, int v) { // 从v出发，深度优先遍历G
	visited[v]=true; // 已访问
	for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w))
		if(!visited[w]){
			DFS(G,w);
		}
	print(v); //输出顶点
}
```
- DFS判断回路的方法：
	- 对visited结点设置3种类型的值，在一个结点访问时（即正在访问结点的邻接点未从栈返回时），visited设置为2，当访问完所有的邻接点时，visited设置为1，表示已访问。在访问结点i的邻接点时，如果访问到了visited值为2的结点，则存在回路。
---
# 关键路径
- AOE网：在带权有向图中，以**顶点表示事件**，以**有向边表示活动**，以**边上的权值表示完成该活动的开销**（如完成活动所需的时间），称之为⽤边表示活动的⽹络，简称**AOE⽹ (Activity On Edge NetWork)**
	- ![](http://oss.pyaxy.xyz/img/20250823155530635.png)
- AOE⽹具有以下两个性质：
	1. 只有在某顶点所代表的事件发⽣后，从该顶点出发的各有向边所代表的活动才能开始；
	2. 只有在进⼊某顶点的各有向边所代表的活动都已结束时，该顶点所代表的事件才能发⽣。另外，有些活动是可以并⾏进⾏的

- ![](http://oss.pyaxy.xyz/img/20250823155623575.png)
- 在**AOE⽹中仅有⼀个**⼊度为0的顶点，称为**开始顶点（源点）**，它表示整个⼯程的开始；也**仅有⼀个**出度为0的顶点，称为**结束顶点（汇点）**，它表示整个⼯程的结束。
- 从源点到汇点的有向路径可能有多条，所有路径中，具有**最⼤路径⻓度**的路径称为**关键路径**，⽽把关键路径上的活动称为**关键活动**

- 求关键路径：
	- 规定：
		- ![](http://oss.pyaxy.xyz/img/20250823155959115.png)
			- 事件vk的最早发⽣时间ve(k)——决定了所有从vk开始的活动能够开⼯的最早时间。
				- 比如v1事件最早从0时刻开始。v2最早开始的时间为1时刻（等待a2做完），**而v3最早可以在4时刻开始（需要等a1和a3做完）**
			- 活动ai的最早开始时间e(i)——指该活动弧的起点所表⽰的事件的最早发⽣时间。
				- 比如a1和a2活动最早可以在0时刻开始。a3活动最早在1时刻开始（等待V2开始）。
		- ![](http://oss.pyaxy.xyz/img/20250823160020345.png)
			- 事件vk的最迟发⽣时间vl(k)——它是指在不推迟整个⼯程完成的前提下，该事件最迟必须发⽣的时间。
				- 比如v4事件最迟需要在6时刻发生（与最早发生时间一致）；v3最迟需要在4时刻发生（a4需要耗时2，在4之后开始则不满足V4的期限）；v2最迟在1时刻开始（a3耗时3），**v1最迟在0时刻发生（需要同时满足v2与v3的最迟开始时间）**
			- 活动ai的最迟开始时间l(i)——它是指该活动弧的终点所表示事件的最迟发⽣时间与该活动所需时间之差。
				- a4的最迟开始时间为4时刻（a4耗时2，最迟在4开始可以满足在6时刻结束，晚了则超时）
		- ![](http://oss.pyaxy.xyz/img/20250823161224695.png)
			- 活动的时间余量d(i)=l(i)-e(i)——表示在不增加整个工程总时间的情况下，活动ai可以拖延的时间。
			- **若⼀个活动的时间余量为零**，则说明该活动**必须要如期完成**，**d(i)=0即l(i) = e(i)的活动ai是关键活动**
			- **关键活动**组成的路径就是**关键路径**
	- 过程：
		1. 求所有事件的最早发⽣时间 ve( )
			 - ![](http://oss.pyaxy.xyz/img/20250823161557145.png)
		2. 求所有事件的最迟发⽣时间 vl( )
			- ![](http://oss.pyaxy.xyz/img/20250823161624847.png)
		3. 求所有活动的最早发⽣时间 e( )
			- ![](http://oss.pyaxy.xyz/img/20250823161639621.png)
		4. 求所有活动的最迟发⽣时间 l( )
			- ![](http://oss.pyaxy.xyz/img/20250823161703882.png)
		5. 求所有活动的时间余量 d( )
			- d(i)=0即l(i) = e(i)的活动ai是关键活动
- 关于关键活动、冠军路径
	- 若关键活动耗时增加，则整个⼯程的⼯期将增⻓
	- 缩短关键活动的时间，可以缩短整个⼯程的⼯期
	- 当缩短到⼀定程度时，关键活动可能会变成⾮关键活动
	- 可能有多条关键路径，只提⾼⼀条关键路径上的关键活动速度并不能缩短整个⼯程的⼯期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短⼯期的⽬的。
		- ![](http://oss.pyaxy.xyz/img/20250823161846485.png)