# 图的基本概念
- **图G（graph）**由**顶点集V（vertex）**和**边集E（edge）**组成，记为G = (V, E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。若V = {v1, v2, … , vn}，则用|V|表示图G中顶点的个数，也称图G的阶，E = {(u, v)}，用|E|表示图G中边的条数。
- ![](http://oss.pyaxy.xyz/img/20250818170912009.png)

> [!note]
> 注意：线性表可以是空表，树可以是空树，但图不可以是空，即**V一定是非空集**


---
## 无向图、有向图
- 
- 若E是**无向边**（简称**边**）的有限集合时，则图G为**无向图**。边是顶点的无序对，**记为(v, w)或(w, v)**，因为==(v, w) = (w, v)==，其中v、w是顶点。可以说顶点w和顶点v互为邻接点。边(v, w)依附于顶点w和v，或者说边(v, w)和顶点v、w相关联。
	- ![](http://oss.pyaxy.xyz/img/20250818171134180.png)
- 若E是有向边（也称弧）的有限集合时，则图G为有向图。弧是顶点的有序对，记为<v, w>，其中v、w是顶点，v称为弧尾，w称为弧头，<v, w>称为从顶点v到顶点w的弧，也称v邻接到w，或w邻接自v。<v, w> ≠ <w, v>。
	- ![](http://oss.pyaxy.xyz/img/20250818171143980.png)
---
## 简单图、多重图
- 简单图：
	1. 不存在重复边
	2. 不存在自己连自己的边。
	3. **本课程只讨论简单图**
	4. ![](http://oss.pyaxy.xyz/img/20250818171345806.png)
- 多重图
	- 与简单图对应的图。
	- ![](http://oss.pyaxy.xyz/img/20250818171331927.png)
---
## 顶点的度、入度、出度
- 对于==无向图==：**顶点的度**是指依附于该顶点的边的条数记为TD(v)。
	- 在具有n个顶点、e条边的无向图中，$$\sum_{i=1}^{n}{TD(v_i)}=2e$$即无向图的全部顶点的度的和等于边数的2倍（每条边贡献2个度）。
- 对于==有向图==：
	- **入度**是以顶点v为终点的有向边的数目，记为ID(v)；
	- **出度**是以顶点v为起点的有向边的数目，记为OD(v)。
	- **顶点v的度**等于其入度和出度之和，即TD(v) = ID(v) + OD(v)。
	- 在具有n个顶点、e条边的有向图中，$$\sum_{i=1}^{n}{ID(v_i)} = \sum_{i=1}^{n}{OD(v_i)} = e$$
---
## 顶点-顶点关系描述
- 路径——顶点vp到顶点vq之间的一条路径是指顶点序列，V1,V2,V3...,V6
- 回路——第一个顶点和最后一个顶点相同的路径称为回路或环
- 简单路径——在路径序列中，顶点不重复出现的路径称为简单路径。
- 简单回路——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为简单回路。
- 路径长度——路径上边的数目
- 点到点的距离——从顶点u出发到顶点v的==最短路径==若存在，则==此路径的长度称为从u到v的距离==。若从u到v根本不存在路径，则记该距离为无穷（∞）。
- 无向图中，若从顶点v到顶点w有路径存在，则称v和w是**连通**的
- 有向图中，若从顶点v到顶点w和从顶点w到顶点v之间都有路径，则称这两个顶点是**强连通**的
---
## 连通图、强连通图
- ![](http://oss.pyaxy.xyz/img/20250818172404923.png)
- 若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。
	- 连通图的常见考点 #常考 
		- 对于n个顶点的无向图G
		- 若为==连通图==，则==最少==有n-1条边
		- 若为==非连通图==，则==最多==$C_{n-1}^{2}$条边（孤立一个点，剩下的顶点两两相连）
		- 注意： #易错点 
			- 一个n个顶点n条边的图不一定是连通图，因为可以拿出其中n-1个顶点把n条边填进去剩下的一个顶点孤立。==但他一定有环==。
			- 一个有n个结点的图无论怎么都是连通图的情况为`e>(n-1)(n-2)/2`，拿出n-1个结点填满边，只要再多一条边就怎么都是连通的了。
- ![](http://oss.pyaxy.xyz/img/20250818172704684.png)
- 若图中任何一对顶点都是强连通的，则称此图为强连通图。
	- 强连通图的常见考点 #常考 
		- 对于n个顶点的有向图G
		- 若G是==强连通图==，则==最少==有n条边（形成回路）

> [!note]
> 注意：连通图是在无向图的范畴中，强连通图是在有向图的范畴中。

---
## 子图
- ![](http://oss.pyaxy.xyz/img/20250818173144495.png)
- 设有两个图G = (V, E)和G' = (V', E')，若V'是V的子集，且E'是E的子集，则称G'是G的**子图**。
- 若有满足V(G¢) = V(G)的子图G¢，则称其为G的**生成子图**（保留所有顶点）。
>[!note]
>并非挑出任意几条边、几个顶点就可以构成子图
>![](http://oss.pyaxy.xyz/img/20250818173229840.png)
---
## 连通分量
- **无向图**中的==**极大连通子图**==称为==连通分量==
	- 子图必须连通，且包含尽可能多的顶点和边。
- ![](http://oss.pyaxy.xyz/img/20250818190236606.png)
---
## 强连通分量
- **有向图**中的==极大强连通子图==称为有向图的==强连通分量==
	- 子图必须强连通，同时包含尽可能多的顶点和边
- ![](http://oss.pyaxy.xyz/img/20250818190357785.png)
---
## 生成树
- ==连通图==的**生成树**是==包含图中全部顶点的一个**极小连通子图**（边的数量尽可能少）==。
	- 若图有n个顶点，则他的生成树有n-1条边（相当于一棵树中有n-1度）。对于生成树而言：删除一条边会让其变成非连通图；增加一条边会让其形成一个回路
- ![](http://oss.pyaxy.xyz/img/20250818190705148.png)
---
## 生成森林
- 在==非连通图==中，其==连通分量的生成树==构成了非连通图的**生成森林**。
- ![](http://oss.pyaxy.xyz/img/20250818190757730.png)
---
## 边的权、带权图/网
- 边的权——在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的**权值**。
- 带权图/网——边上带有权值的图称为**带权图**，也称**网**。
- 带权路径长度——当图是带权图时，**一条路径上所有边的权值之和**，称为该路径的带权路径长度
- e.g.
	- ![](http://oss.pyaxy.xyz/img/20250818191002964.png)
## 几种特殊的图
- **无向完全**图：无向图中任意两个顶点之间都有边
	- n个顶点的无向完全图有`n(n-1)/2`条边
- **有向完全图**：有向图中任意两个顶点之间都有两条方向相反的**弧**
	- n个顶点的有向完全图有`n(n-1)`条边
- **稀疏图**：边很少的图，一般认为`E<VlogV`为稀疏图
- **稠密图**：边很多的图
- **树**：==不存在回路==，且**连通**的无向图
	- #常考 n个顶点的树，必有n-1条边；则n个顶点的图，当边数大于n-1时一定有回路
- **有向树**：1个顶点的入度为0（根结点），其余顶点的入度均为1的有向图。
---
# 图的存储
## 邻接矩阵法
- ![](http://oss.pyaxy.xyz/img/20250822183751211.png)
- 对于无向图：
	- 邻接矩阵G\[A]\[B]=1表示AB之间有边
	- 第i个结点的**度**=**第i行（或第i列）**的非零元素个数
- 对于有向图：
	- 邻接矩阵G\[A]\[B]=1表示A->B之间有边
	- 第i个结点的**出度**=**第i行**的非零元素个数
	- 第i个结点的**入度**=**第i列**的非零元素个数
	- 第i个结点的**度**=**第i行、第i列**的非零元素个数之和_
- 邻接矩阵法求顶点的度/入度/出度的时间复杂度为$O(|V|)$
- 邻接矩阵的代码定义
```C
#define MaxVertexNum 100
typedef struct{
	char Vex[MaxVertexNum]; // 顶点表
	int Edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵、边表
	int vexnum,arcnum // 图当前的顶点数与边数/弧数
}MGraph;
```
---
- 邻接矩阵存储带权图
- ![](http://oss.pyaxy.xyz/img/20250822184328939.png)
	- 邻接矩阵中的数值存储边的权重。我们认为**权重为∞表示两个顶点不可达**。
- 邻接矩阵存储带权图代码定义
```C
#define MaxVertexNum 100
#define INFINITY 最大的int值
typedef struct{
	char Vex[MaxVertexNum]; // 顶点表
	int Edge[MaxVertexNum][MaxVertexNum]; // 邻接矩阵、边表
	int vexnum,arcnum // 图当前的顶点数与边数/弧数
}MGraph;
```
---
- 邻接矩阵法的性能分析
	- 空间复杂度：$O(|V|^2)$。只与顶点数有关。
	- 适合存储**稠密图**。
	- 无向图的邻接矩阵是对称矩阵，可以压缩存储。
	- ![](http://oss.pyaxy.xyz/img/20250822184742821.png)
---
- 邻接矩阵法的性质
	- 设图G的邻接矩阵为A（矩阵元素为0/1），则$A^n$的元素A^n\[i]\[j]等于由顶点i到顶点j的长度为n的路径的数目。
	- ![](http://oss.pyaxy.xyz/img/20250822184907163.png)
## 邻接表法
- 由于数组实现的邻接矩阵法空间复杂度高，不适合存储稀疏图，我们使用顺序+链式存储方式存储图，即**邻接表法**。
- ![](http://oss.pyaxy.xyz/img/20250822185043207.png)
- 邻接表法的代码实现
```C
// 顶点
typedef struct VNode{
	VertexType data;
	ArcNode *first;
}VNode,AdjList[MaxVertexNum];

// 边
typedef struct ArcNode{
	int adjvex; // 边指向哪个顶点
	struct ArcNode *next; // 指向下一弧的指针。
	int weight; // 权重
}ArcNode;

// 图
typedef struct{
	AdjList vertices;
	int vexnum,arcnum;
}ALGraph;
```
- 对于无向图
	- 边结点的数量是2|E|，整体空间复杂度为O(|V| + 2|E|)
- 对于有向图
	- 边结点的数量是|E|，整体空间复杂度为O(|V| + |E|)
- 只要确定了顶点编号，图的邻接矩阵表示方式唯一。但图的邻接矩阵表示方式不唯一。
---
## 十字链表法
>[!info]
>当使用邻接矩阵法和邻接表法存储**有向图**时：**邻接矩阵**空间复杂度**较高**；**邻接表**找**顶点的入边**不方便，因此我们引入了十字链表法。

- ==十字链表法用于存储**有向图**。==
- ![](http://oss.pyaxy.xyz/img/20250822190034088.png)
- 空间复杂度：$O(|V|+|E|)$
- 如何在十字链表中找到一个结点的所有**出边**：沿着**绿色**的路线找。
- 如何在十字链表中找到一个结点的所有**入边**：沿着**橙色**的路线找。
---
## 邻接多重表法
>[!info]
>当使用邻接矩阵法和邻接表法存储**无向图**时：**邻接矩阵**空间复杂度**较高**；**邻接表**每条边对应两份冗余信息，删顶点/边等操作时间复杂度高，因此我们引入了邻接多重表。

- - ==邻接多重表法用于存储**无向图**。==
- ![](http://oss.pyaxy.xyz/img/20250822190918295.png)
- 邻接多重表法每条边只有一份数据，因此空间复杂度为$O(|E|+|V|)$
- 删除边、删除结点等操作很方便。
---
## 上面几种存储方式等优缺点
- ![](http://oss.pyaxy.xyz/img/20250822191136283.png)
---
## 图的基本操作
- Adjacent(G,x,y)：判断图G是否存在边<x, y>或(x, y)。
- Neighbors(G,x)：列出图G中与结点x邻接的边。
- InsertVertex(G,x)：在图G中插入顶点x。
- DeleteVertex(G,x)：从图G中删除顶点x。
- AddEdge(G,x,y)：若无向边(x, y)或有向边<x, y>不存在，则向图G中添加该边。
- RemoveEdge(G,x,y)：若无向边(x, y)或有向边<x, y>存在，则从图G中删除该边。
- ==FirstNeighbor(G,x)==：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
- ==NextNeighbor(G,x,y)==：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。
- Get_edge_value(G,x,y)：获取图G中边(x, y)或<x, y>对应的权值。
- Set_edge_value(G,x,y,v)：设置图G中边(x, y)或<x, y>对应的权值为v。
- 还有==图的遍历算法==，包括深度优先和广度优先。
---
### 时间复杂度分析
#### Adjacent(G,x,y)
- 判断图G是否存在边<x, y>或(x, y)。
- 对于无向图：
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)~O(|V|)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)~O(|V|)
#### Neighbors(G,x)
- 列出图G中与结点x邻接的边。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(|V|)
	- 邻接表的时间复杂度：O(1)~O(|V|)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(|V|)
	- 邻接表的时间复杂度：求出边：O(1)~O(|V|)；求入边：O(|E|)
#### InsertVertex(G,x)
- 在图G中插入顶点x。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)
#### DeleteVertex(G,x)
- 从图G中删除顶点x。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(|V|)
	- 邻接表的时间复杂度：O(1)~O(|E|)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(|V|)
	- 邻接表的时间复杂度：删出边：O(1)~O(|V|)；删入边：O(|E|)
#### AddEdge(G,x,y)
- 若无向边(x, y)或有向边<x, y>不存在，则向图G中添加该边。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)
#### RemoveEdge(G,x,y)
- 若无向边(x, y)或有向边<x, y>存在，则从图G中删除该边。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)~O(|V|)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)
	- 邻接表的时间复杂度：O(1)~O(|V|)
#### FirstNeighbor(G,x)
- 求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)~O(|V|)
	- 邻接表的时间复杂度：O(1)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)~O(|V|)
	- 邻接表的时间复杂度：出边邻接点：O(1)；入边邻接点：O(1)~O(|E|)
####  NextNeighbor(G,x,y)
- 假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1。
- 对于无向图
	- 邻接矩阵的时间复杂度：O(1)~O(|V|)
	- 邻接表的时间复杂度：O(1)
- 对于有向图
	- 邻接矩阵的时间复杂度：O(1)~O(|V|)
	- 邻接表的时间复杂度：出边邻接点：O(1)；入边邻接点：O(1)~O(|E|)
#### Get_edge_value(G,x,y)
- 获取图G中边(x, y)或<x, y>对应的权值。
- 其时间复杂度与[[图#Adjacent(G,x,y)]]雷同，核心都在于找到对应的边。
#### Set_edge_value(G,x,y,v)
- 设置图G中边(x, y)或<x, y>对应的权值为v。
- 其时间复杂度与[[图#Adjacent(G,x,y)]]雷同，核心都在于找到对应的边。
---
# 图的遍历
## 广度优先遍历（BFS）
- ⼴度优先遍历（Breadth-First-Search,BFS）要点：
	1. 找到与⼀个顶点相邻的所有顶点
	2. 标记哪些顶点被访问过
	3. 需要⼀个辅助队列
- ==FirstNeighbor(G,x)==：求图G中顶点x的第⼀个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1。
- ==NextNeighbor(G,x,y)==：假设图G中顶点y是顶点x的⼀个邻接点，返回除y之外顶点x的下⼀个邻接点的顶点号，若y是x的最后⼀个邻接点，则返回-1。
- 代码实现
```C
bool visited[MAX_VERTEX_NUM]; // 访问标记数组，初始为false

void BFSTraverse(Graph G){ // 对图G进行BFS遍历
	for(int i = 0; i < G.vexnum; i++)
		visited[i]=false; // 初始化标记数组
	InitQueue(Q); // 初始化队列
	for(int i = 0; i < G.vexnum; i++){ // 从 0 开始遍历
		if(!visited[i]) // 对每个连通分量进行 BFS
			BFS(G, i);
	}
}
// 从v出发进行BFS
void BFS(Graph G, int v){
	visit(v);
	visited[v] = true;
	EnQueue(Q, v);
	while(!isEmpty(Q)){
		DeQueue(Q, v);
		for(w = FirstNeighbor(G, v); w>=0; w = NextNeighbor(G, v, w))
		// 遍历所有邻接点
		if(!visited[w]){ // w未访问	
			visit(w); // 访问顶点w
			visited[w] = true; // 标记为已访问
			EnQueue(Q, w); // 顶点w入队
		}
	}
}
```
> [!note]
> 如果是非连通图，则需要在BFSTraverse函数中把每个没有访问过的顶点进行BFS遍历。因此==对于无向图，调用BFS的次数=连通分量数==

---
### 复杂度分析
- 空间复杂度：最坏情况下起始顶点与其他每个都相连，辅助队列大小为O(|V|)
- 时间复杂度分析：
	- 核心思想：访问每个顶点的时间+访问每个顶点的邻接点的时间
	- 对于**邻接矩阵**存储的图：访问n个顶点需要O(n)时间，每个顶点的邻接点访问都需要O(n)时间。**时间复杂度=$O(n^2)$**
	- 对于**邻接表**存储的图：访问n个结点需要O(n)时间，查找各个顶点的邻接点共需要O(e)时间。**时间复杂度=$O(n+e)$**
### 广度优先生成树
- 在广度优先遍历的过程中，除了BFS起始结点外，每个结点都有唯一一个前驱访问结点，因此将遍历过程走过的边保留即可得到广度优先生成树。
- ⼴度优先⽣成树由⼴度优先遍历过程确定。
	- 同⼀个图的**邻接矩阵**表示⽅式**唯⼀**，因此⼴度优先**遍历序列唯⼀**，广度优先**生成树也唯一**
	- 同⼀个图**邻接表**表示⽅式**不唯⼀**，因此⼴度优先**遍历序列不唯⼀**，广度优先**生成树也不唯一**
- 对于非连通图的广度优先遍历，可得到广度优先生成森林。
	- ![](http://oss.pyaxy.xyz/img/20250822212115444.png)
## 深度优先遍历（DFS）
- 与树的[[树与二叉树#先根遍历]]类似。
- 代码实现：
```C
bool visited[MAX_VERTEX_NUM]; // 访问标记数组
void DFSTraverse(Graph G){ // 对图G进行DFS遍历
	for(int i = 0; i < G.vexnum; i++)
		visited[i]=false; // 初始化标记数组
	for(int i = 0; i < G.vexnum; i++){ // 从 0 开始遍历
		if(!visited[i]) // 对每个连通分量进行 DFS
			DFS(G, i);
	}
}

// 从v出发，对图G进行DFS
void DFS(Graph G, int v){
	visit(v); // 访问v
	visited[v] = true; // 标记为已访问
	// v的邻接点w们
	for(w = FirstNeighbor(G,v); w>=0; w = NextNeighbor(G,v,w)){
		if(!visited[w]) // w未被访问
			DFS(G, w);
	}
}
```
- **深度优先遍历可以判断图中是否有环（回路）**
### 复杂度分析
- 空间复杂度：来⾃函数调⽤栈，**最坏情况，递归深度为O(|V|)；最好情况，递归深度为O(1)**
- 时间复杂度：
	- 核心思想：访问各结点所需时间+探索各条边所需时间
	- **邻接矩阵**存的图：访问 |V| 个顶点需要O(|V|)的时间，查找每个顶点的邻接点都需要O(|V|)的时间，⽽总共有|V|个顶点。**时间复杂度=$O(|V|^2)$**
	- **邻接表**存的图：访问 |V| 个顶点需要O(|V|)的时间，查找各个顶点的邻接点共需要O(|E|)的时间。**时间复杂度=O(|V|+|E|)**
### 深度优先生成树
- 深度优先⽣成树由深度优先遍历过程确定。
	- 同⼀个图的**邻接矩阵**表示⽅式**唯⼀**，因此深度优先**遍历序列唯⼀**，深度优先**生成树也唯一**
	- 同⼀个图**邻接表**表示⽅式**不唯⼀**，因此深度优先**遍历序列不唯⼀**，深度优先**生成树也不唯一**
- 对于非连通图的深度优先遍历，可得到深度优先生成森林。
---
## 图的遍历与图的连通性分析
- 对**无向图**进行**BFS/DFS遍历**，调用**BFS/DFS**函数的次数=连通分量数。
	- 对于**连通图**，只需**调用一次**BFS/DFS。
- 对**有向图**进行**BFS/DFS遍历**
	- 若起始顶点到其他各顶点都有路径，则只需调⽤1次BFS/DFS 函数
	- 对于**强连通图**，从任⼀结点出发都只需调⽤1次 BFS/DFS函数
---
# 最小生成树
## 最小生成树的概念
- 连通图的[[图#生成树]]是包含图中全部顶点的一个极小连通子图。要求边尽可能少且保持连通。
- 对于⼀个**带权连通⽆向图**G = (V, E)，⽣成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有⽣成树的集合，若T为R中**边的权值之和最⼩的⽣成树**，则T称为G的**最⼩⽣成树（Minimum-Spanning-Tree, MST）。**
	- 最小生成树可能有多个，但边的权值和为最小且是唯一的。
	- 最小生成树的边数：最小生成树也是生成树，因此边数等于顶点数-1，少一条则不连通，多一条则会出现回路。
	- 如果一个连通图本身就是树，则其最小生成树就是本身。
	- 只有连通图才有生成树，非连通图只有生成森林。
---
## Prim算法生成最小生成树
- 算法过程：
	- ==从某⼀个顶点开始构建⽣成树；每次将代价最⼩的新顶点纳⼊⽣成树，直到所有顶点都纳⼊为⽌。==
- 时间复杂度：$O(|V|^2)$，因此适用于边稠密的图。
---
## Kruskal算法生成最小生成树
- 算法过程
	- 每次选择⼀条权值最⼩的边，使这条边的两头连通（原本已经连通的就不选）。
- 时间复杂度：$O(|E|log_2|E|)$，因此适用于边稀疏的图。