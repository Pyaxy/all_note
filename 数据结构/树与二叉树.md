# 树的基本概念
- ![](http://oss.pyaxy.xyz/img/20250730153408730.png)
- ==空树==：结点为0的树
- 非空树的特性：
	- 只有一个根结点
	- 只有根结点没有前驱结点
	- 只有叶子结点没有后继结点
	- 除根结点外，每个结点只有一个前驱
- 当结点数n>1时，其余结点可以分为m个互不相交的有限集合，每个集合为一个子树。
- ![](http://oss.pyaxy.xyz/img/20250730153719248.png)
- 树是一种==递归定义==的数据结构
---
## 一些基本术语
- ![](http://oss.pyaxy.xyz/img/20250730154022275.png)
- 祖先结点：从一个结点出发，向上到根结点经过的所有结点。
- 子孙结点：从一个结点出发，到叶子结点经过的所有结点。
- 双亲结点：一个结点的直接前驱
- 孩子结点：一个结点的直接后继
- 兄弟结点：有同一个前驱
- 堂兄弟结点：在同一层的结点
- **两个结点之间的路径：从上向下的、有方向的路径**
---
## 结点、树的属性描述
- 结点的层次（深度）：从上往下数（默认从1开始）
- 结点的高度：从下往上数
- 树的高度（深度）：总共多少层
- ==结点的度==：有几个孩子（分支）
- ==树的度==：各个结点度的最大值
---
## 有序树与无序树
- 有序树：树中结点的各个子树从左到右是有次序的，不可互换
- 无序树：树中结点的各个子树从左到右是无次序的，可互换
---
## 森林
- 森林是多个互不相交的树的集合。
---
## 树的常考性质
1. #常考 常见考点1：==结点数=总度数（孩子数量）+1（根结点）==
2. 常见考点2：**度为m的树** vs **m叉树**：
	- **度为m的树**要求必须出现一个结点有m个孩子。
	- **m叉树**只规定每个结点最多有m个孩子，所有节点少于m个孩子的树依然是合法的m叉树
3. 常见考点3：度为m的树/m叉树 第i层最多有$m^{i-1}$个结点
	- ![](http://oss.pyaxy.xyz/img/20250730155937928.png)
4. 常见考点4：高度为h的m叉树至多有$\frac{m^h-1}{m-1}$个结点（等比数列求和）
5. 常见考点5：高度为h的m叉树至少有h个结点；高度为h、度为m的树至少有h+m-1个结点。
	- ![](http://oss.pyaxy.xyz/img/20250730160348220.png)
6. 常见考点6：有n个结点的m叉树的最小高度为$\lceil log_m(n(m-1) + 1) \rceil$
	- ![](http://oss.pyaxy.xyz/img/20250730160749666.png)
---
# 二叉树
## 二叉树的基本概念
- ![](http://oss.pyaxy.xyz/img/20250730161308411.png)
- 二叉树是n（n≥0）个结点的有限集合：
	1. 为==空二叉树==，即n = 0。
	2. 或者由一个==根结点==和两个互不相交的被称为根的==左子树==和==右子树==组成。左子树和右子树又分别是一棵二叉树。
- 特点：
	- 每个结点至多只有两棵子树
	- 左右子树不能颠倒（二叉树是**有序树**）
- 二叉树的5种状态
	- ![](http://oss.pyaxy.xyz/img/20250730161507582.png)
- 几种特殊的二叉树
	- 满二叉树：一棵高度为h，含有$2^h-1$个结点的二叉树
		- ![](http://oss.pyaxy.xyz/img/20250730161732595.png)
		- 只有最后一层有叶子结点
		- 不存在度为1的结点
		- 按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为$\lfloor i/2 \rfloor$（如果有的话）。
	- 完全二叉树：当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二叉树。
		- ![](http://oss.pyaxy.xyz/img/20250730162011472.png)
		- 只有最后两层可能有叶子结点。
		- 最多只有一个度为1的结点，且一定为左孩子。
		- 按层序从1开始编号，结点i的左孩子为2i，右孩子为2i+1；结点i的父节点为$\lfloor i/2 \rfloor$（如果有的话）。
		- i ≤ 𝑛/2 为分支结点，i> 𝑛/2 为叶子结点。
	- 二叉排序树：**左子树**上所有结点的关键字均**小于**根结点的关键字；**右子树**上所有结点的关键字均**大于**根结点的关键字。
		- ![](http://oss.pyaxy.xyz/img/20250730162407402.png)
		- 左子树和右子树又各是一棵二叉排序树
	- 平衡二叉树：树上任一结点的**左子树**和**右子树**的**深度之差不超过1**。
		- ![](http://oss.pyaxy.xyz/img/20250730162645363.png)
		- 平衡二叉树更有搜索效率
---
## 二叉树的常考性质
- #常考 常见考点1：设非空二叉树中度为0、1和2的结点个数分别为n0、n1和n2，则==**n0= n2+ 1**==（叶子结点 = 二分支结点 + 1）#常见考点
	- 证明：
	- ![](http://oss.pyaxy.xyz/img/20250730163919961.png)
- 常见考点2：二叉树第i层至多有$2^{i-1}$个结点（i≥1）
- 常见考点3：高度为h的二叉树至多有$2^h−1$个结点（满二叉树）
---
## 完全二叉树的常考性质
- 常见考点1：具有n个（n > 0）结点的完全二叉树的高度h为==$\lceil log_2(n + 1)\rceil$==或$\lfloor log_2n \rfloor + 1$
	- 证明：
	- ![](http://oss.pyaxy.xyz/img/20250730165557449.png)
	- ![](http://oss.pyaxy.xyz/img/20250730165806637.png)
- #常考 常见考点2：对于完全二叉树，可以由的结点数n推出度为0、1和2的结点个数为n0、n1和n2。
	- 具体推断过程：
		- 完全二叉树最多只有一个度为1的结点，即n1=0或1
		- n0 = n2 + 1，即n0+n2为奇数
		- n = n0 + n1 + n2
		- ![](http://oss.pyaxy.xyz/img/20250730170031469.png)
---
## 二叉树的顺序存储
```C
#define MaxSize 100
typedef struct TreeNode {
	ElemType value;
	bool IsEmpty
}TreeNode;
TreeNode t[MaxSize];
```
- 完全二叉树的顺序存储
	- 定义一个长度为MaxSize的数组t，按照**从上至下**、**从左至右**的顺序依次存储完全二叉树中的各个结点
	- ![](http://oss.pyaxy.xyz/img/20250730171613720.png)
	- ![](http://oss.pyaxy.xyz/img/20250730171644806.png)
- 非完全二叉树的顺序存储
	- 如果不是完全二叉树，依然按层序将各节点顺序存储将无法反应结点之间的逻辑关系
	- 解决方法：==一定要把二叉树的结点编号与完全二叉树对应起来==
		- ![](http://oss.pyaxy.xyz/img/20250730171807690.png)
		- ![](http://oss.pyaxy.xyz/img/20250730171819780.png)
	- 但是上面的判断是否有左孩子/右孩子/是否是叶子结点/分支结点的方式就失效了，需要结合`IsEmpty`字段判断。判断i结点的左孩子存在条件为`tree[2i].IsEmpty = false`
- 顺序存储的缺点
	- ![](http://oss.pyaxy.xyz/img/20250730172311470.png)
	- ![](http://oss.pyaxy.xyz/img/20250730172400786.png)
	- 最坏情况：高度为h且只有h个结点的单支树（所有结点只有右孩子），也至少需要$2^h-1$个存储单元。
	- 因此：==二叉树的顺序存储结构，只适合存储完全二叉树==
---
## 二叉树的链式存储
```C
typedef struct BiTreeNode {
	ElemType data; // 数据域
	struct BiTreeNode *lchild, *rchild; // 左、右孩子指针
}BiNode, *BiTree;
```
- n个结点的二叉链表共有2n个指针域，其中n-1个非空指针，==n+1个空指针，可以用于构造线索二叉树== ^d1b605
- 对于二叉链树来讲，寻找结点的左、右孩子很容易，但是寻找其父结点很难。只能从根开始遍历，==如果实际需求中需要频繁使用到结点的父结点，那么需要在结点结构体中加上指向父结点的指针字段==，我们称之为三叉链表。
---
## 二叉树的遍历
### 二叉树的先/中/后序遍历
- 分为先/中/后序遍历：基于树的递归特性决定的次序规则。
	- 递归特性：
		- **先**序遍历：**根**左右（**N**LR）
		- **中**序遍历：左**根**右（L**N**R）
		- **后**序遍历：左右**根**（LR**N**）
- 算数表达式的分析树：
	- ![](http://oss.pyaxy.xyz/img/20250803151220898.png)
	- 先序遍历：`-+a*b-cd/ef`为前缀表达式
	- 中序遍历：`a+b*(c-d)-e/f`为中缀表达式
	- 后序遍历：`abcd-*+ef/-`为后缀表达式
---
#### 先序遍历代码实现
- ==先序遍历==的递归实现：
- 具体思想：
	1. 如果二叉树为空，则什么也不做；
	2. 若二叉树非空：
		1. ==访问根结点；==
		2. 先序遍历左子树；
		3. 先序遍历右子树；
```C
// 先序遍历
void PreOrder(BiTree T){
	if(T!=NULL){
		visit(T); // 访问根结点
		PreOrder(T->lchild); // 递归遍历左子树
		PreOrder(T->rchild); // 递归遍历右子树
	}
}
```
---
#### 中序遍历代码实现
- ==中序遍历==的递归实现：
- 具体思想：
	1. 如果二叉树为空，则什么也不做；
	2. 若二叉树非空：
		1. 中序遍历左子树；
		2. ==访问根结点；==
		3. 中序遍历右子树；
```C
// 中序遍历
void InOrder(BiTree T){
	if(T!=NULL){
		InOrder(T->lchild); // 递归遍历左子树
		visit(T); // 访问根结点
		InOrder(T->rchild); // 递归遍历右子树
	}
}
```
---
#### 后序遍历代码实现
- ==后序遍历==的递归实现：
- 具体思想：
	1. 如果二叉树为空，则什么也不做；
	2. 若二叉树非空：
		1. 后序遍历左子树；
		2. 后序遍历右子树；
		3. ==访问根结点；==
```C
// 后序遍历
void PostOrder(BiTree T){
	if(T!=NULL){
		PostOrder(T->lchild); // 递归遍历左子树
		PostOrder(T->rchild); // 递归遍历右子树
		visit(T); // 访问根结点
	}
}
```
---
#### 使用递归思想求树的深度
- 思想：树的深度=Max（左子树深度，右子树深度）+1
```C
int treeDepth(BiTree T){
	if (T == NULL)
		return 0;
	else {
		int l = treeDepth(T->lchild)
		int r = treeDepth(T->rchild)
		return l > r ? l + 1 : r + 1;
	}
}
```
---
### 二叉树的层次遍历
- 层次遍历：基于树的层次特性决定的次序规则
- ![](http://oss.pyaxy.xyz/img/20250803152929331.png)
- 算法思想：
	1. 初始化一个辅助[[栈和队列#队列|队列]]
	2. 根结点入队
	3. 若队列非空，则队头结点出队，访问该结点，将其左/右孩子加入队尾（如果有）；
	4. 重复3步直到队列空
#### 层次遍历代码实现
```C
// 二叉树的结点（链式存储）
typedef struct BiTNode{
	char data;
	struct BiTNode *lchild, *rchild;
}BiTNode,*BiTree;

// 链队结点
typedef struct LinkNode{
	BiTNode *data;
	struct LinkNode *next;
}LinkNode;

typedef struct{
	LinkNode *front, *rear; // 队头、队尾
}LinkQueue;

// 层次遍历
void LevelOrder(BiTree T) {
	LinkQueue Q;
	InitQueue(Q); // 初始化队列
	BiTNode *p;
	EnQueue(Q, T); // 根结点入队
	while(!isEmpty(Q)){ // 队列不空则循环
		DeQueue(Q, p); // 队头结点出队
		visit(p); // 访问出队结点
		if(p->lchild != NULL)
			EnQueue(Q, p->lchild); // 左孩子入队
		if(p->rchild != NULL)
			EnQueue(Q, p->rchild); // 右孩子入队
	}
	
}
```
---
### ==由遍历序列构造二叉树==
- 已知中序+其他任一种遍历序列构造出一个二叉树
- 核心思想：在其他任一种遍历序列中==找到树根结点==，在中序遍历序列中在根结点左边的结点在其左子树上，在其右边的结点在其右子树上。
>[!info]
>==只有知道中序+其他任一种遍历序列才可唯一确定一棵树==，剩下的序列两两组合是不能唯一确定一棵二叉树。

---
#### 前序 + 中序遍历序列
- 核心思想：先序遍历序列中==第一个结点即为根结点==
- ![](http://oss.pyaxy.xyz/img/20250803154833151.png)
---
#### 后序 + 中序遍历序列
- 核心思想：后序遍历序列中==最后一个结点为根结点==
- ![](http://oss.pyaxy.xyz/img/20250803155000400.png)
---
#### 层序 + 中序遍历序列
- 核心思想：层序遍历序列中==第一个结点为根结点==
- ![](http://oss.pyaxy.xyz/img/20250803155145442.png)
---
## 线索二叉树
### 线索二叉树的概念
![](http://oss.pyaxy.xyz/img/20250804175954006.png)
>[!question]
>在传统二叉树中，当为一个二叉树按照某一遍历方法遍历之后产生了对应的遍历序列时，如对于上图的二叉树`T`，其中序遍历序列为`D G B E A F C`，当实际应用中需要寻找到先序遍历序列中`G`的前驱/后继是哪个结点时，传统的二叉树逻辑结构是无法立刻推出的，==必须从根结点开始遍历==，这样做很不方便，因此我们引入了**线索二叉树**。

- 由于n个结点的二叉树，有n+1个空链域，参考[[树与二叉树#^d1b605]]。其可用于记录前驱、后继信息
- ![](http://oss.pyaxy.xyz/img/20250804181158355.png)
	- 前驱**线索**：由左孩子指针充当。
	- 后继**线索**：由右孩子指针充当。
	- 那么当孩子指针既充当孩子又充当线索时，我们需要引入标志来区分两者。==我们引入了`ltag`和`rtag`标志，当`tag=0`时，表示指针指向孩子。==
- 我们称新建立的数据结构为**线索链表**
- 因此线索二叉树是一种**物理**结构
```C
//线索二叉树结点
typedef struct ThreadNode{
	ElemType data;
	struct ThreadNode *lchild, *rchild;
	int ltag, rtag;
}ThreadNode, *ThreadTree;
```
- 同理我们可以画出先序线索二叉树与后序线索二叉树，只需要把线索指针指向对应遍历序列中的前驱与后继即可。
---
### 线索二叉树的构造
- 思想：土方法，使用`pre`指针记录遍历过程中每一个访问结点的前驱结点。并在访问的过程中修改指针。
#### 中序线索化
- 假设我们已经有了一棵建立好的树，其已经包括了`ltag`与`rtag`字段。那么我们中序线索化的代码如下：
```C
ThreadNode *pre = NULL; // 全局变量，记录当前访问结点的前驱

void CreateInThread(ThreadTree T){
	pre = NULL;
	if(T!=NULL){
		InThread(T);
		pre->rtag = 1; // [易错点]处理遍历的最后一个结点
	}
}

void InThread(ThreadTree T){
	if(T!=NULL) {
		InThread(T->lchild) // 先遍历左子树
		visit(T) // 访问中间根结点，更新指针
		InThread(T->rchild) // 最后遍历右子树
	}
}

void visit(ThreadNode *q) {
	if (q->lchild == NULL){ // 左子树为空
		q->lchild = pre;
		q->ltag = 1;
	}
	if (pre != NULL && pre->rtag == NULL){ // 更新前驱结点的后继线索
		pre->rchild = q;
		pre->rtag = 1;
	}
	pre = q;
}
```
- #易错点 在上述代码中，访问完一个结点后需要更新`pre`指针指向当前结点，==在下一个结点访问的时候才会生成`pre`结点的后继线索==，因此访问最后一个结点之后`pre`结点还未生产后继线索，**需要在最后手动修改`rtag=1`**
--- 
#### 先序线索化
```C
ThreadNode *pre = NULL;

// 先序线索化二叉树T
void CreatePreThread(ThreadTree T){
	if(T!=NULL){
		PreThread(T);
		pre->rtag = 1; // [易错点]处理遍历的最后一个结点
	}
}
void PreThread(ThreadTree T){
	if(T!=NULL){
		visit(T);
		if(T->ltag = 0) // [易错点] // 需要区分lchild是否是孩子
			PreThread(T->lchild);
		PreThread(T->rchild);
	}
}

void visit(ThreadNode *q){
	if(q->lchild == NULL){ // 左子树为空
		q->lchild = pre;
		q->ltag = 1;
	}
	if(pre != NULL && pre->rchild == NULL){ // 更新前驱结点的后继线索
		pre->rchild = q;
		pre->rtag = 1;
	}
	pre = q;
}
```
- #易错点 
	1. 在上述代码中，访问完一个结点后需要更新`pre`指针指向当前结点，==在下一个结点访问的时候才会生成`pre`结点的后继线索==，因此访问最后一个结点之后`pre`结点还未生产后继线索，**需要在最后手动修改`rtag=1`**
	2. 在上述代码中，由于是先序遍历（根 左 右）访问结点，当访问根结点时，**其左指针有可能会被修改指向先序线索，而访问完根结点后访问其左指针，需要判断其左指针指向的到底是孩子还是前驱**。而右指针不需要判断是因为**在`visit`函数中其右孩子是不会产生后继线索的**，后继线索的生成是在下一个结点访问的时候才会生成`pre`结点的后继线索，因此不会影响到当前结点的右指针。==是否需要添加判断语句的标准就是看前面访问结点时是否会对其左右指针产生影响。==
--- 
#### 后序线索化
- 后序线索化与中序线索化一样。
```C
ThreadNode *pre = NULL;

void CreatePostThread(ThreadTree T){
	if(T!=NULL){
		 PostThread(T); // 后序线索化二叉树
		 pre->rtag = 1; // 处理遍历的最后一个结点。
	}
}

void PostThread(ThreadTree T){
	if(T!=NULL){
		PostThread(T->lchild); // 左
		PostThread(T->rchild); // 右
		visit(T); // 根
	}
}

void visit(ThreadNode *q){
	if(q->lchild == NULL) {// 左子树为空
		q->lchild = pre;
		q->ltag = 1;
	}
	if(pre != NULL && pre->rchild == NULL) {
		pre->rchild = q; // 建立前驱结点的后继线索
		pre->rtag = 1;
	}
	pre = q;
}
```
---
### 线索二叉树中找前驱/后继
#### 中序线索二叉树中找前驱/后继
- 在中序线索二叉树中找到指定结点`*p`的**中序后继**`next`
	1. 若`p->rtag == 1`，则可以直接找到后继。
	2. 若`p->rtag == 0`，则
		- ![](http://oss.pyaxy.xyz/img/20250816164757170.png)
		- 因此为右子树中最左下结点
```C
// 找到P为根的子树中，中序遍历访问的第一个结点
ThreadNode *FirstNode(ThreadNode *p){
	// 找到最左下的结点，不一定是叶结点。
	while(p->ltag == 0) p = p->lchild;
	return p;
}

// 在中序二叉线索树中找到结点p的后继结点。
ThreadNode *nextnode(ThreadNode *p){
	if(p->rtag == 0) return FirstNode(p->rchild);
	else return p->rchild; // rtag == 1直接返回后继线索
}

// 应用：对中序线索二叉树进行中序遍历（迭代法）
void InOrder(ThreadTree T){
	for(ThreadNode *p = FirstNode(T); p != NULL; p = nextnode(p))
		visit(p);
}
```

- 在中序线索二叉树中找到指定结点`*p`的**中序前驱**`pre`
	1. 若`p->ltag == 1`，则可以直接找到前驱。
	2. 若`p->ltag == 0`，则
		- ![](http://oss.pyaxy.xyz/img/20250816165600361.png)
		- `pre` 为p的左子树中最右下的结点
```C
// 找到P为根的子树中，中序遍历访问的最后一个结点
ThreadNode *LastNode(ThreadNode *p){
	// 找到最右下的结点，不一定是叶结点。
	while(p->rtag == 0) p = p->rchild;
	return p;
}

// 在中序二叉线索树中找到结点p的前驱结点。
ThreadNode *prenode(ThreadNode *p){
	if(p->ltag == 0) return LastNode(p->lchild);
	else return p->lchild; // rtag == 1直接返回后继线索
}

// 应用：对中序线索二叉树进行逆向中序遍历（迭代法）
void RevInOrder(ThreadTree T){
	for(ThreadNode *p = LastNode(T); p != NULL; p = prenode(p))
		visit(p);
}
```
---
#### 先序线索二叉树中找前驱/后继
- 在先序线索二叉树中找到指定结点`*p`的**先序后继**`next`
	1. 若`p->rtag == 1`，则可以直接找到后继。
	2. 若`p->rtag == 0`，则
		- ![](http://oss.pyaxy.xyz/img/20250816170121371.png)
- 在先序线索二叉树中找到指定结点`*p`的**先序前驱**`pre`
	1. 若`p->ltag == 1`，则可以直接找到前驱。
	2. 若`p->ltag == 0`，则
		- 先序遍历序列（根 左 右）中，根结点的左右子树中只可能存储根的后继。如果我们使用三叉链表找到了根结点的父结点。
		- ![](http://oss.pyaxy.xyz/img/20250816170348027.png)
---
#### 后序线索二叉树中找前驱/后继
-  在后序线索二叉树中找到指定结点`*p`的**后序前驱**`pre`
	1. 若`p->ltag == 1`，则可以直接找到前驱。
	2. 若`p->ltag == 0`，则
		- ![](http://oss.pyaxy.xyz/img/20250816171202131.png)
- 在后序线索二叉树中找到指定结点`*p`的**后序后继**`next`
	1. 若`p->rtag == 1`，则可以直接找到后继。
	2. 若`p->rtag == 0`，则
		- 后序遍历序列（左 右 根）中，根结点的左右子树只可能存储根的前驱。如果我们使用三叉链表找到了根结点的父结点。
		- ![](http://oss.pyaxy.xyz/img/20250816171406687.png)

> [!tips]
> 上述的找前驱/后继思想不必死记硬背，重点在于理解，考试时推理出即可。
> 另外在上面的先序/后序线索树中，并不能找到所有的前驱/后继。具体的判断方法：**在先序（根左右）线索树中，根结点的前驱结点不在其左右子树中；后序（左右根）线索树中，根结点的后继结点不在其左右子树中。**需要使用三叉链表或者从头遍历才能找到。

---
#常考 
- T的中序遍历序列为一个升序序列，可以采用将T的所有左右子树互换位置使其中序遍历序列为降序序列。
- 线索二叉树是一种**物理**结构，其由链表**存储**在计算机中。

# 树的存储结构
## 树的逻辑结构
- 树是n（n≥0）个结点的有限集合，**是一种递归定义的数据结构**，n = 0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：
	1. 有且仅有一个特定的称为__根__的结点。
	2. 当n > 1时，其余结点可分为m（m > 0）个互不相交的有限集合T1, T2,…, Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。
	- ![](http://oss.pyaxy.xyz/img/20250816204054582.png)
---
## 双亲表示法
### 双亲表示法存储树
- 思想：使用数组存储各个结点。每个结点中保留**数据元素、父结点的编号**。根结点的父结点指向-1。
- ![](http://oss.pyaxy.xyz/img/20250816204321832.png)
```C
#define MAX_TREE_SIZE 100 // 树中最多结点数量
typedef struct{
	ElemType data; // 数据元素
	int parent; // 父结点位置
}PTNode;

typedef struct{
	PTNode nodes[MAX_TREE_SIZE]; // 树
	int n; // 树的结点总数
}PTree;
```
---
### 双亲表示法存储森林
- 思路：拥有多个根结点，那么就有多个结点的父结点指向-1。
- ![](http://oss.pyaxy.xyz/img/20250816204712070.png)
---
### 双亲表示法的优缺点
- 优点：找父结点很方便
- 缺点：找孩子不方便，只能遍历。
- 适用于：找父亲多，找孩子少的场景。如： 并查集 #todo link一下。
---
## 孩子表示法
- 思路：用数组顺序存储各个结点，每个结点的孩子使用链表存储。每个结点中保存数据元素、孩子链表头指针。其结构相当于邻接表 #todo link一下。
### 孩子表示法表示树
- ![](http://oss.pyaxy.xyz/img/20250816205143445.png)
```C
struct CTNode{
	int child; // 孩子结点在数组中的位置
	struct CTNode *next; // 下一个孩子
};

typedef struct {
	ElemType data;
	struct CTNode *firstChild; // 第一个孩子
}CTBox;

typedef struct {
	CTBox nodes[MAX_TREE_SIZE];
	int n, r; // n为结点个数，r为根结点位置。
}
```
---
### 孩子表示法表示森林
- 如果需要使用孩子表示法表示森林，那么需要记录多个根的位置。
- ![](http://oss.pyaxy.xyz/img/20250816205530929.png)
---
### 孩子表示法的优缺点
- 优点：找孩子很方便
- 缺点：找父结点不方便。只能遍历
- 适用于：找孩子多，找父亲少的场景。如：服务流程树
---
## ==孩子兄弟表示法==
- 思想：与二叉树类似，都采用二叉链表实现，但是两个指针的含义有所不同。其两个指针分别为`firstchild`与`nextsibling`，分别表示结点的第一个孩子、结点的右边第一个兄弟。
```C
typedef struct CSNode{
	ElemType data; // 数据域
	struct CSNode *firstchild, *nextsibling; // 第一个孩子和右兄弟指针
}
```
### 孩子兄弟表示法表示树
- ![](http://oss.pyaxy.xyz/img/20250816210121739.png)
- 如图所示，A结点的`firstchild`指向B，`nextsibling`指向空；B结点的`firstchild`指向E，`nextsibling`指向C。
---
### 孩子兄弟表示法表示森林
- 思路：与表示树一样，只不过根结点的`nextsibling`为森林中下一棵树的根结点，我们认为森林中每棵树的根结点为平级的兄弟关系。
- ![](http://oss.pyaxy.xyz/img/20250816210451747.png)
---
# 树、森林与二叉树的转换
>[!note]
> 核心思想：在上面的[[树与二叉树#==孩子兄弟表示法==|孩子兄弟表示法中]]，其存储结构为二叉链表，因此树、森林与二叉树的转换问题本质上是孩子兄弟表示法的表示。
## 树转化为二叉树
- 方法：
	1. 先在二叉树中，画一个根结点。
	2. 按“==树的层序==”依次处理每个结点。
- 处理每个结点时：如果当前结点有孩子，就把所有孩子结点“用右指针串成糖葫芦”，并在二叉树中把这个“糖葫芦”的第一个孩子挂在当前结点的左指针下方。
- ![](http://oss.pyaxy.xyz/img/20250816211145011.png)
---
## 森林转化为二叉树
- 方法：
	1. 先把所有树的根结点画出来，在二叉树中用右指针串成糖葫芦。
	2. 按“森林的层序”依次处理每个结点。
- 处理一个结点的方法是：如果当前处理的结点在树中有孩子，就把所有孩子结点“用右指针串成糖葫芦”，并在二叉树中把第一个孩子挂在当前结点的左指针下方。
- ![](http://oss.pyaxy.xyz/img/20250816211330987.png)

> [!warning]
> 森林中各棵树的根节点视为平级的兄弟关系。

---
## 二叉树转化为树
- 方法：
	1. 先画出树的根节点。
	2. 从树的根节点开始，按==“树的层序”==恢复每个结点的孩子。
- 如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前结点的下方。
- ![](http://oss.pyaxy.xyz/img/20250816211547509.png)
---
## 二叉树转化为森林
- 方法：
	1. 先把二叉树的根节点和“一整串右指针糖葫芦”拆下来，作为多棵树的根节点。
	2. 按==“森林的层序”==恢复每个结点的孩子
- 如何恢复一个结点的孩子：在二叉树中，如果当前处理的结点有左孩子，就把左孩子和“一整串右指针糖葫芦”拆下来，按顺序挂在当前结点的下方。
- ![](http://oss.pyaxy.xyz/img/20250816211704685.png)
---
# 树、森林的遍历
## 树的遍历
### 先根遍历
- 先根遍历：若树非空，先访问根结点，再依次对每棵子树进行先根遍历。
- 先根遍历是一种深度优先遍历。
```C
void PreOrder(TreeNode *R){
	if (R!=NULL)
		visit(R);
		while(R还有下一个子树T)
			PreOrder(T);
}
```
- ==树的先根遍历序列与这棵树对应的二叉树的先序遍历序列相同==
---
### 后根遍历
- 后根遍历：若树非空，先依次对每棵子树进行后根遍历，最后再访问根结点。
- 后跟遍历也是一种深度优先遍历。
```C
void PostOrder(TreeNode *R){
	if(R!=NULL){
		while(R有下一个子树T){
			PostOrder(T);
		}
		visit(R);
	}
}
```
- ==树的后根遍历序列与这棵树对应的二叉树的中序遍历序列相同==
---
### 层次遍历
- 具体见[[树与二叉树#二叉树的层次遍历]]
- 使用队列实现
	1. 若树非空，则根节点入队
	2. 若队列非空，队头元素出队并访问，同时将该元素的孩子依次入队
	3. 重复2直到队列为空
---
## 森林的遍历
### 森林的先序遍历
- 若森林为非空，则按如下规则进行遍历：
	1. 访问森林中第一棵树的根结点。
	2. 先序遍历第一棵树中根结点的子树森林。
	3. 先序遍历除去第一棵树之后剩余的树构成的森林。
- ==效果等同于对各个树进行先根遍历；也等同于依次对森林对应的二叉树进行先序遍历==
### 森林的中序遍历
- 若森林为非空，则按如下规则进行遍历：
	1. 中序遍历森林中第一棵树的根结点的子树森林。
	2. 访问第一棵树的根结点。
	3. 中序遍历除去第一棵树之后剩余的树构成的森林。
- ==效果等同于对各个树进行后根遍历；也等同于依次对森林对应的二叉树进行中序遍历==