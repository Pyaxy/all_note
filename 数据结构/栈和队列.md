---
tags:
  - 4️⃣0️⃣8️⃣
  - 数据结构
  - 栈
  - 队列
---
# 栈
## 栈的定义
- **栈（stack）**是==只允许在一端进行插入或删除==的[[线性表]]
- 重要术语：栈顶、栈底、空栈
- ![](http://oss.pyaxy.xyz/img/20250526195024839.png)
- 特点：后进先出/Last In First Out(LIFO)
- 逻辑结构：与普通[[线性表]]相同
- 数据的运算：插入、删除操作有区别
---
## 栈的基本操作
```C
InitStack(&S); // 初始化空栈S，分配内存空间
DestroyStack(&S); // 销毁栈。销毁并释放内存空间

Push(&S, x); // 进栈，若S未满，则将x加入栈顶
Pop(&S, &x); // 出栈，若S非空，则将栈顶元素弹出并通过x返回。

GetTop(&S, &x) // 获取栈顶元素。若栈非空，则获取栈顶元素并通过x返回
```

>[!note]
>n个不同元素进栈，出栈元素不同的排列的个数位$\frac{1}{n+1}C^n_{2n}$，称为卡特兰(Catalan)数，不要求掌握。

## 栈的顺序存储实现（顺序栈）
- 用顺序存储方式实现的栈
- 顺序栈的定义
```C
#define MaxSize 10
typedef struct{
	ElemType data[MaxSize]; // 静态数组存放栈中元素
	int top; // 栈顶指针
} SqStack;
```
---
- 顺序栈的初始化
```C
void InitStack(SqStack &S) {
	S.top=-1;
}
```
---
- 顺序栈的Push操作
```C
bool Push(SqStack &S, ElemType x) {
	if (S.top == MaxSize - 1) // 栈满
		return false;
	S.data[++S.top] = x; // 指针向上移动且元素进栈
	return true;
}
```
---
- 顺序栈的Pop操作
```C
bool Pop(SqStack &S, ElemType &x) {
	if (S.top == -1) // 栈空
		return false;
	x = S.data[S.top--]; // 栈顶元素出栈
	return true;
}
```
---
- 顺序栈的读取栈顶操作
```C
bool GetTop(SqStack &S, ElemType &x) {
	if (S.top == -1) // 栈空
		return false;
	x = S.data[S.top]; // 读取栈顶
	return true;
}
```
---
## 共享栈
- 两个栈共享同一片内存空间
- ![](http://oss.pyaxy.xyz/img/20250526203230718.png)
- ![](http://oss.pyaxy.xyz/img/20250526203301953.png)
---
## 栈的链式存储实现（链栈）
- 头插法实现链栈
	- 头节点认为是栈顶
	- 插入只能在头节点插入
	- 删除只能删除头节点后的节点
### 带头节点的链栈
- 基本定义
```C
typedef struct LiNode{
	ElemType data;
	struct LiNode *next;
} *LiStack;
```
---
- 初始化
```C
bool InitStack(LiStack &s) {
	s = (LiStackNode*)malloc(sizeof(LiStackNode));
	s->next = NULL; // 新栈为空
	return true;
}
```
---
- 判空
```C
// 判空
bool StackEmpty(LiStack &s){
	if(s->next == NULL)
		return true;
	return false;
}
```
---
- 入栈
```C
// 入栈
bool push(LiStack &s, Elemtype x){
	LiStackNode* node = (LiStackNode*)malloc(sizeof(LiStackNode)); // 新建节点
	node->data = x; // 赋值
	node->next = s->next; // 指向目前的栈顶
	s->next = node; // 成为新的栈顶
	return true;
}
```
---
- 出栈
```C
// 出栈
bool pop(LiStack &s, Elemtype &x){
	if(StackEmpty(s)) // 判空
		return false;
	LiStackNode* node = s->next;
	x = s->next->data;
	s->next = s->next->next;
	free(node);
	return true;
}
```
---
- 取栈顶
```C
bool getTop(LiStack &s, Elemtype &x){
	if(StackEmpty(s))
		return false;
	x = s->next->data;
	return true;
}
```
---
### 不带头节点的链栈
- 定义
```C
typedef struct Linknode{
	Elemtype data;
	struct Linknode* next;
}ListackNode, *LiStack;	// 不带头节点的链栈的表头指针
```
---
- 初始化
```C
// 初始化
bool InitLink(LiStack &s){
	s = NULL;
	return true;
}
```
---
- 判空
```C
// 判空
bool StackEmpty(LiStack &s){
	if(s==NULL)
		return true;
	return false;
}
```
---
- 入栈
```C
bool push(LiStack &s, Elemtype x){
	// 一般链栈不需要判满，很难上溢
	ListackNode *node = (ListackNode*)malloc(sizeof(ListackNode));
	node->data = x;
	node->next = s;
	s = node;
	return true;
}
```
---
- 出栈
```C
bool pop(LiStack &s, Elemtype &x){
	if(StackEmpty(s))
		return false;
	x = s->data;
	ListackNode *node = s;
	s = s->next;
	free(node);
	return true;
}
```
---
- 获取栈顶元素
```C
bool getTop(LiStack &s, Elemtype &x){
	if(StackEmpty(s))
		return false;
	x = s->data;
	return true;
}
```
---
# 队列
## 队列的定义
- 队列（Queue）是只允许==在一端插入，另一端删除==的[[线性表]]。
- 重要术语：队头、队尾、空队列
- 特点：先进先出/First In First Out(FIFO)
- ![](http://oss.pyaxy.xyz/img/20250526211217757.png)
---
## 队列的基本操作
```C
InitQueue(&Q); // 初始化队列
DestroyQueue(&Q); // 销毁队列

EnQueue(&Q, x); // 入队
DeQueue(&Q, &x); // 出队

GetHead(&Q, &x); // 获取队头元素

IsEmpty(&Q) // 判空
```
---
## 队列的顺序存储实现（顺序队列）
- 使用连续空间存储队列
- 定义
```C
#define MAXSIZE 10
typedef struct{
	ElemType data[MAXSIZE];
	int front, rear;
} SqQueue;
```
- 其中
	- front 指向==队头元素==
	- rear 指向==下一个可以插入的位置==或==队尾元素==，不同的指向操作的具体逻辑不一样，需要区分，下面的代码都是队尾指向下一个可以插入的位置。
- 按照上面的逻辑，初始化代码为
```C
void InitQueue(SqQueue &Q) {
	Q.rear = Q.front = 0;
}
```
---
- 判空操作
```C
bool IsEmpty(SqQueue &Q) {
	return Q.rear == Q.front
}
```
---
- 入队
```C
bool EnQueue(SqQueue &Q, ElemType x) {
	if (队列满)
		return false;
	Q.data[Q.rear] = x;
	Q.rear++;
	return true;
}
```
>[!note]
>上述代码中，当队列的尾指针上升`MAXSIZE`的时候，并不代表着队列已满，会造成假溢出，如下图所示，队列中有3个空位，但是rear已经上升到顶部了。为了解决假溢出问题，我们可以使用循环队列。
>![](http://oss.pyaxy.xyz/img/20250526213225103.png)
---
## 循环队列
- 当`rear`指针上升到顶时，我们使用`rear = (rear + 1) % MAXSIZE`来让前进的下一个位置为`0`处，将存储空间在逻辑上变为闭环。
- ![](http://oss.pyaxy.xyz/img/20250526213512832.png)
>[!循环队列队头队尾指针操作]
>- 初始时：`Q.front = Q.rear = 0`
>- 队首指针进1：`Q.front = (Q.front + 1) % MAXSIZE`
>- 队尾指针进1：`Q.rear = (Q.rear + 1) % MAXSIZE`
>- 队列长度：==`(Q.rear + MAXSIZE - Q.front) % MAXSIZE`==
- 但是当队列存满时，我们会发现`Q.rear = Q.front`，这时队列是否为空还是满就混淆了，为了区分队空还是队满，我们可以采用下面的方法
	- 牺牲一个单元来区分队空还是队满，规定队满时标识为==队尾指针的下一个位置为队头指针==（最常用的方法）。如图所示。
	- ![](http://oss.pyaxy.xyz/img/20250526214259220.png)
	- 类型中增设Size数据成员，表示元素个数。队空时Size = 0，队满时Size = MAXSIZE
	- 类型中增设tag数据成员。当出队操作后置tag为0，当tag = 0时，如果头尾指针相等则为空；当入队操作后置tag为1，当tag = 1时，如果头尾指针相等则队满。
- 那么我们可以总结出循环队列的基本操作
- 初始化
```C
void InitQueue(SqQueue &Q) {
	Q.rear = Q.front = 0;
}
```
---
- 判空
```C
void IsEmpty(SqQueue Q) {
	return Q.rear == Q.front;
}
```
---
- 判满
```C
void IsFull(SqQueue Q) {
	return (Q.rear + 1) % MAXSIZE == Q.front;
}
```
---
- 入队
```C
bool EnQueue(SqQueue &Q, ElemType x) {
	if ((Q.rear + 1)%MAXSIZE == Q.front) // 判断队满
		return false;
	Q.data[Q.rear] = x; // 赋值
	Q.rear = (Q.rear + 1)%MAXSIZE; //指针前移
	return true;
}
```
---
- 出队
```C
bool DeQueue(SqQueue &Q, ElemType &x) {
	if (Q.rear == Q.front) // 判断队空
		return false;
	x = Q.data[Q.front];
	Q.front = (Q.front + 1)%MAXSIZE;
	return true;
}
```
---
- 获取队列长度
```C
bool Length(SqQueue &Q) {
	return (Q.rear + MAXSIZE - Q.front) % MAXSIZE;
}
```
---
## 队列的链式存储实现（链队列）
- 使用链表来实现队列。
- ![](http://oss.pyaxy.xyz/img/20250530143525928.png)
- 定义
```C
typedef struct LinkNode{ // 链式队列节点
	ElemType data;
	struct LinkNode *next;
}LinkNode;

typedef struct{ //链式队列
	LinkNode *front, *rear; // 队头、队尾指针
}LinkQueue;
```
---
- 初始化（带头节点）：队首/队尾指针都指向头节点
```C
void InitQueue(LinkQueue &Q) {
	Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));
	Q.front->next = NULL;
}
```
---
- 判空（带头节点）：队首队尾指针指向同一个地方
```C
bool Empty(LinkQueue &Q) {
	if (Q.front == Q.rear)
		return true;
	return false;
}
```
---
- 入队（带头节点）：尾插到队尾
```C
bool EnQueue(LinkQueue &Q, ElemType x) {
	LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode));
	s->data = x;
	s->next = NULL;
	Q.rear->next = s;
	Q.rear = s;
	return true;
}
```
---
- 出队（带头节点）：需要处理最后一个节点出队时`rear`指针的变化
```C
bool DeQueue(LinkQueue &Q, ElemType &x) {
	if (Q.front == Q.rear) // 空队
		return false;
	LinkNode* s = Q.front->next;
	x = s->data;
	Q.front->next = s->next;
	if (Q.rear == s) { // 出队的是最后一个元素
		Q.rear = Q.front;
	}
	free(s);
	return true;
}
```
---
- 初始化（不带头节点）：队首、队尾指向`NULL`
```C
void InitQueue(LinkQueue &Q) {
	Q.front = NULL;
	Q.rear = NULL;
}
```
---
- 判空（不带头节点）：队首/队尾指向`NULL`
```C
bool Empty(LinkQueue &Q) {
	return Q.front == NULL;
}
```
---
- 入队（不带头节点）：第一次插入时需要特殊处理
```C
void EnQueue(LinkNode &Q, ElemType x) {
	LinkNode* s = (LinkNode*)malloc(sizeof(LinkNode));
	s->data = x;
	s->next = NULL;

	if (Q.front == NULL) {// 第一个元素入队
		Q.front = s;
		Q.rear = s;
	} else {
		Q.rear->next = s;
		Q.rear = s;
	}
}
```
---
- 出队（不带头节点）：最后一个元素出队时需要将`front`和`rear`置空
```C
bool Dequeue(LinkNode &Q, ElemType &x) {
	if (Q.front == NULL)
		return false;
	LinkNode* p = Q.front;
	x = p->data;
	Q.front = p->next;
	if (Q.rear == p){
		Q.front = NULL;
		Q.rear = NULL;
	}
	free(p)
	return true;
}
```
---
## 双端队列
- 总览
- ![](http://oss.pyaxy.xyz/img/20250530150723997.png)
- 考点：给定某一个双端队列，判断一个输出序列是否合法。
---
# 栈和队列的异同
>[!info]
>#易错点
>栈和队列都属于[[绪论#(1) 逻辑结构|线性结构]]的数据结构，只是运算限定不同。