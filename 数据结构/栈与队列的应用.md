---
tags:
  - 4️⃣0️⃣8️⃣
  - 数据结构
  - 栈
  - 队列
---
# 栈的应用
## 栈的括号匹配
- 遇到左括号就入栈
- 遇到右括号，就“抵消”一个左括号
- 匹配失败情况：
	1. 左括号多余
	2. 右括号多余
	3. 左右括号不匹配
- ![](http://oss.pyaxy.xyz/img/20250530153253396.png)
- 代码
```C
#define MaxSize 10
typedef struct{
	char data[MaxSize];
	int top;
} SqStack;

// 初始化栈
void InitStack(SqStack &S);

// 判空
void StackEmpty(SqStack S);

// 入栈
void Push(SqStack &S, char c);

// 出栈
void Pop(SqStack &S, char &x);

// 括号匹配
bool bracketMatch(char str[], int length) {
	SqStack S;
	InitStack(&S);
	for(int i = 0; i < length; i++){
		char c = str[i];
		// 左括号就入栈
		if(c == '(' || c == '[' || c == '{'){
			Push(S, c);
			continue;
		}
		// 右括号就判断是否有匹配的左扩号

		// 没有左括号
		if(StackEmpty(S))
			return false;
		char lb;
		Pop(S, lb);
		if(c == ')' && lb != '(')
			return false;
		if(c == ']' && lb != '[')
			return false;
		if(c == '}' && lb != '{')
			return false;
		
	}
	if(StackEmpty(S))
		return false;
	return true;
}
```
> [!tip]
> 在写大题的过程中，如果需要使用到数据结构的具体操作，需要在代码最上面声明出来，不需要描述具体实现。

---
## 栈的表达式求值
### 三种算术表达式
- 中缀表达式
	- 运算符以中缀形式处于操作数的中间。
	- 如：a+b
- 后缀表达式
	- 运算符以后缀形式处于操作数的后面
	- 如：ab+
- 前缀表达式
	- 运算符以前缀形式处于操作数的前面
	- 如：+ab
---
### ==中缀转后缀==的==手算方法==：
	1. 确定中缀表达式中**各个运算符的操作顺序**
	2. 选择下一个运算符，按照==\[左操作数 右操作数 运算符]== 的方式组合成一个新的操作数。
	3. 如果还有运算符没处理，就继续step2
> [!info]
> 运算顺序不唯一、因此对应的后缀表达式也不唯一
> ==左优先==原则：只要左边的运算符能先进行运算，就优先算左边的。这样可以保证手算与机算结果一致。
---
### ==中缀转前缀==的==手算方法==：
	1. 确定中缀表达式中**各个运算符的操作顺序**
	2. 选择下一个运算符，按照==\[运算符 左操作数 右操作数]== 的方式组合成一个新的操作数。
	3. 如果还有运算符没处理，就继续step2
> [!info]
> 运算顺序不唯一、因此对应的前缀表达式也不唯一
> ==右优先==原则：只要右边的运算符能先进行运算，就优先算右边的。这样可以保证手算与机算结果一致。
---
### 后缀表达式的手算方法
- 从左往右扫描，每遇到一个运算符，就让==运算符前面最近的两个操作数==执行对应运算，==合体为一个操作数==
- 注：两个操作数的左右顺序
---
### 后缀表达式的机算方法（==栈==实现）
1. 从左往右扫描下一个元素，直到处理完所有元素
2. 若扫描到操作数则入栈，继续step1
3. 若扫描到运算符，则弹出两个栈顶元素，==执行对应运算==（**栈顶的为右操作数**），结果压回栈中，继续step1
---
### 前缀表达式的机算方法（==栈==实现）
1. 从右往左扫描下一个元素，直到处理完所有元素
2. 若扫描到操作数则入栈，继续step1
3. 若扫描到运算符，则弹出两个栈顶元素，==执行对应运算==（**栈顶的为左操作数**），结果压回栈中，继续step1
---
### 中缀表达式转后缀表达式的机算（用==栈==实现）
- 初始化一个栈，用于保存暂时不能确定运算顺序的运算符。
- 规则
	- 从左到右处理各个元素，直到末尾。
		1. 遇到**操作数**，直接加入后缀表达式。
		2. 遇到**界限符**。遇到`(`直接入栈；遇到`)`直接弹出栈内的运算符并加入后缀表达式，直到弹出`(`为止。注意：界限符不加入后缀表达式。
		3. 遇到**运算符**。依次弹出优先级高于/等于当前运算符的所有运算符，并加入后缀表达式，直到`(`或者栈空，再将当前运算符入栈。
	- 处理完所有字符后，将剩余的运算符依次弹出，并加入后缀表达式。
---
### 中缀表达式的计算（用栈实现）
- 思想：中缀转后缀（机算）+后缀的机算
- 初始化两个栈，**操作数栈**与**运算符栈**
	- 若扫描到操作数，压入操作数栈。
	- 若扫描到运算符或界限符，则按照中缀转后缀的算法逻辑压入运算符栈，期间也会==弹出==运算符，==每弹出一个运算符，就需要弹出操作数栈顶的两个元素并执行相应运算，结果再压回操作数栈==）
---
## 栈的应用：递归
- 函数调用时，需要一个栈存储：
	1. 调用的返回地址（#1）
	2. 实参（a、b）
	3. 局部变量（x）
![](http://oss.pyaxy.xyz/img/20250719211531715.png)
- 栈栈递归中的应用
- 适合递归解决的问题：可以把原始问题分解为**属性相**同，但**规模较小**的问题。
	- 计算阶乘
	- 斐波那契数列
---
# 队列的应用
## 树的层次遍历
- 思想：新建一个队列，将每个节点的所有叶子节点加入到队列中，将当前节点出队，继续访问队首，实现了树的按层次遍历。
- 具体见：[[树与二叉树#二叉树的层次遍历]]
---
## 图的广度优先遍历
- 思想：新建一个队列，将起点加入队列，访问起点相邻的节点，起点出队，访问队首，继续将队首元素相邻且没有被遍历过的节点加入队列中。
---
## 队列在操作系统中的应用
- 进程争抢使用有限的系统资源时，FCFS（first come first service，先来先服务）是一种常用策略。
---
## 队列实现的缓冲区
- 解决主机速度与外部设备速度不匹配的问题，比如：打印机中使用队列组织打印数据。