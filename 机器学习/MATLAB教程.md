## MATLAB教程

### 基本操作

基本的数据运算，包括加减乘除。

逻辑运算：

```matlab
> 1 == 2	% flase
ans	= 0
> 1 ~= 2
ans = 1
> 1 && 0;
```

注：在matlab中`%`号表示注释，不等于用`~=`来判断，`;`用于阻止结果的输出，如上面代码的最后一个命令，加上`;`后无输出结果。

#### 打印输出变量

```matlab
> a = pi;
> a
a =	3.1416


> disp(a)
 3.1416
 
 
> disp(sprintf('2 decimals: %0.2f', a))
2 decimals: 3.14
```

最后一项命令为C语言的旧式语法，`sprintf()`命令返回一个字符串，再通过`disp()`命令输出。

#### 控制打印长度

```matlab
> 1 = pi;
> format long
a =	3.14159265358979
> format short
> a
a = 3.1416

```

#### 矩阵

```matlab
> A = [1 2; 3 4; 5 6]
A =
	1	2
	3	4
	5	6
```

其中`;`表示矩阵切换到下一行

```matlab
> v = 1:0.1:2
v =

  列 1 至 8

    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000

  列 9 至 11

    1.8000    1.9000    2.0000
```

上述的命令的具体含义为，从1为起点，步长为0.1，一直增加到2的一个行向量，**如果不设置步长默认为1。**

##### 生成特殊矩阵

```matlab
>> A = ones(2,3)

A =

     1     1     1
     1     1     1
>> zeros(1,3)

ans =

     0     0     0
>> rand(3,3)

ans =

    0.8147    0.9134    0.2785
    0.9058    0.6324    0.5469
    0.1270    0.0975    0.9575
```

在`rand(3,3)`中，会生成一个3x3的矩阵，里面的元素全是位于0到1之间的随机值，`randn()`可以生成满足**高斯分布(正态分布)**的随机值，例如：

```matlab
>> w = -6 + sqrt(10) * (randn(1,10000));
>> hist(w);
```

结果为：

![p1](http://oss.pyaxy.xyz/img/p1.png)

```matlab
>> eye(4)
ans =

     1     0     0     0
     0     1     0     0
     0     0     1     0
     0     0     0     1
```

`eye()`表示生成单位矩阵

### 移动数据

```matlab
>> A = [1 2; 3 4; 5 6];
>> size(A)
ans =
	3	2
>> v = [1 2 3 4]
>> length(v)
ans = 4	%将会返回最大维度的大小，一般用于求向量的大小，而不是用于矩阵
>> pwd
ans = D://.....	%显示当前路径
>> cd 'C:\Users'
```

载入文件：

```matlab
>> load xxxx.txt
>> load('xxxx.txt')
>> who	%可以显示出当前所有的变量
>> whos %可以显示出当前所有变量的详细信息
>> clear X	%删除X变量
>> clear	%删除所有变量
>> save xxx.mat V	%保存文件，把变量V存储为xxx.mat的文件
```

定位元素：

```matlab
>> A = [1 2; 3 4; 5 6];
>> A(3,2)
ans =	6
>> A(2,:)	%":"表示该行或列所有的元素
ans =
	3	4
>> A([1 3], :)	%获取第一行和第三行的所有元素
ans =
	1	2
	5	6
>> A = [A, [100;200;300]]	%可以在右边加一列新的矩阵
A =
     1     2   100
     3     4   200
     5     6   300
>> A(:)	%把A中的所有元素放到一列中
ans =
     1
     3
     5
     2
     4
     6
   100
   200
   300
```

### 计算数据

* 矩阵的乘法

  ```matlab
  >> A = [1 2; 3 4; 5 6];
  >> B = [11 12 13; 14 15 16];
  >> A*B
  ans =
  
      39    42    45
      89    96   103
     139   150   161
  ```

  上面的为矩阵的直接乘法，若要单独对元素进行操作则应该使用`.`

  ```matlab
  >> A = [1 2; 3 4; 5 6];
  >> B = [11 12; 13 14; 15 16];
  >> A.*B
  ans =
  
      11    24
      39    56
      75    96
  ```

  使用`.`可以对元素进行操作，不限于乘法。

* 计算绝对值：

  使用`abs()`命令可以求绝对值

* 矩阵转置：

  ```matlab
  >> A = [1 2; 3 4; 5 6]
  A =
       1     2
       3     4
       5     6
  >> A'
  ans =
       1     3     5
       2     4     6
  ```

  使用标准引号`'`可以求得矩阵的转置

* 逻辑比较：

  ```matlab
  >> a = [1 15 2 0.5];
  >> a < 3
  ans =
     1   0   1   1
  ```

  符合返回1，不符合返回0
  
* `magic()`函数

  `magic(n)`函数将会返回一个n阶的幻方矩阵，该矩阵的特点是每行每列以及对角线上的元素和都相等。

  ```matlab
  >> magic(3)
  ans =
       8     1     6
       3     5     7
       4     9     2
  ```
  
* `find()`函数

  ```matlab
  >> a = [1 15 2 0.5];
  >> find(a < 3 )
  ans =
       1     3     4
  ```

  将会返回符合条件的索引
  
  ```matlab
  >> A = magic(3)
  ans =
       8     1     6
       3     5     7
       4     9     2
  >> [r c] = find(A>=7)
  r =
       1
       3
       2
  c =
       1
       2
       3
  ```
  
  上述代码返回了符合条件的行和列的索引，比如`A(1,1)`大于等于7，`A(3,2)`也大于等于7。

* 求和：

  ```matlab
  >> a = [1 15 2 0.5];
  >> sum(a)
  ans =
     18.5000
  ```

  使用`sum()`函数可以求一个向量中的所有元素之和

  另外有：

  ```matlab
  >> A = magic(9)
  A =
      47    58    69    80     1    12    23    34    45
      57    68    79     9    11    22    33    44    46
      67    78     8    10    21    32    43    54    56
      77     7    18    20    31    42    53    55    66
       6    17    19    30    41    52    63    65    76
      16    27    29    40    51    62    64    75     5
      26    28    39    50    61    72    74     4    15
      36    38    49    60    71    73     3    14    25
      37    48    59    70    81     2    13    24    35
  >> sum(A,1)
  ans =
     369   369   369   369   369   369   369   369   369
  ```

  `sum(A,1)`返回了每列的求和，及把第1维度即每行的元素求和。同理`sum(A,1)`返回每列的求和，及把第2维度即每列的元素求和。

  另外注意，**如果不注明维度，则默认求第一维度即每列的和。**

  如何求对角线的和：

  我们先使用`A.*eye(9)`来使得除了对角线外的所有元素均为0

  ```matlab
  >> A = magic(9);
  >> A.*eye(9)
  ans =
      47     0     0     0     0     0     0     0     0
       0    68     0     0     0     0     0     0     0
       0     0     8     0     0     0     0     0     0
       0     0     0    20     0     0     0     0     0
       0     0     0     0    41     0     0     0     0
       0     0     0     0     0    62     0     0     0
       0     0     0     0     0     0    74     0     0
       0     0     0     0     0     0     0    14     0
       0     0     0     0     0     0     0     0    35
  ```

  接下来只需求这个矩阵的所有元素之和：

  ```matlab
  >> sum(A.*eye(9), 'all')
  ans =
     369
  ```

  我们还可以使用`flipud()`命令来使单位矩阵垂直翻转来求另一条对角线的和：

  ```matlab
  >> A = magic(9);
  >> A.*flipud(eye(9))
  ans =
       0     0     0     0     0     0     0     0    45
       0     0     0     0     0     0     0    44     0
       0     0     0     0     0     0    43     0     0
       0     0     0     0     0    42     0     0     0
       0     0     0     0    41     0     0     0     0
       0     0     0    40     0     0     0     0     0
       0     0    39     0     0     0     0     0     0
       0    38     0     0     0     0     0     0     0
      37     0     0     0     0     0     0     0     0
  >> sum(A.*flipud(eye(9)), 'all')
  ans =
     369
  ```

  

  

* 求积：

  ```matlab
  >> a = [1 15 2 0.5];
  >> prod(a)
  ans =
  	15
  ```

* 取整：

  `floor()`函数可以对数字进行向下取整，`ceil()`函数可以对数字进行向上取整。

* `max()`函数

  * 对向量:

    ```matlab
    >> a = [1 15 2 0.5];
    >> max(a)
    ans = 
  	  15
    ```
    上述例子的`max()`函数返回了一个向量之中的最大值，如果要获取它的索引则有：

    ```matlab
    >> a = [1 15 2 0.5];
    >> [val, ind] = max(a)
    val =
        15
    ind =
         2
    ```
    其中`val`返回了最大元素的值，`ind`返回了其索引
    
  * 对矩阵：

    ```matlab
    >> A = magic(3)
    ans =
         8     1     6
         3     5     7
         4     9     2
    >> max(A,[],1)
    ans =
         8     9     7
    ```
  
    上面的结果返回了每列元素的最大值，后面的1表示对第一维度进行遍历，从第1行到第n行进行比较，返回最大值，从而求出每列最大的元素，同理有`max(A, [], 2)`来求得每行元素的最大值。
  
    当然要记得，**如果对一个矩阵进行如同`max(A)`一般的操作，则默认返回以第一维度求和即每列的最大值。**
  
    如果你想求得一个矩阵中最大的元素，则可以用以下方法：
  
    ```matlab
    >> max(max(A));
    >> max(A, [], 'all');
    ```
  
* 求逆矩阵：
  
  ```matlab
  >> pinv(A)
  ```
  
  使用`pinv()`来求矩阵的逆矩阵
  
### 数据绘制

```matlab
>> t=[0:0.01:1];
>> y1=sin(2*pi*4*t);
>> plot(t,y1)
```

上述命令可以简单的绘制出一个正弦函数：

![数据绘制](http://oss.pyaxy.xyz/img/p2.png)

我们接着输入：

```matlab
>> y2=cos(2*pi*4*t)
>> plot(t,y2);
```

这时你会发现，matlab抹除了之前绘制的sin函数，再绘制出了cos函数，要想把两个曲线绘制到同一个图上，我们可以这样做：

```matlab
>> plot(t,y1);
>> hold on;
>> plot(t,y2,'r');	%将曲线颜色设置为红色
```

`hold on`可以保留之前绘制的内容然后接着绘制新的内容：

![数据绘制3](http://oss.pyaxy.xyz/img/p3.png)

我们还可以在图上添加其他的数据：

```matlab
>> xlabel('time')	%给x轴加上标签
>> ylabel('value')	%给y轴加上标签
>> legend('sin','cos')	%在图上标明曲线的名字
>> title('my plot')	%给图取名字
```

![数据绘制4](http://oss.pyaxy.xyz/img/p4.png)

保存图像：

```matlab
>> print -dpng 'my Plot.png'
```

这会在当前路径保存图片，另外`close`可以把图像关闭

在两张图上绘制：

```matlab
>> figure(1);
>> plot(t,y1);
>> figure(2);
>> plot(t,y2);
```

![5](http://oss.pyaxy.xyz/img/p5.png)

这样我们就得到了两个图

在一个图里画多个独立的曲线：

```matlab
>> subplot(1,2,1);	%这个语句前两个参数表示把图分为1*2的格子，最后一个参数表示使用第一个格子
>> plot(t,y1);
```

![6](http://oss.pyaxy.xyz/img/p6.png)

```matlab
>> subplot(1,2,2);
>> plot(t,y2);
```

![7](http://oss.pyaxy.xyz/img/p7.png)

调整轴的范围：

```matlab
>> axis([0.5 1 -1 1])	%前两个调整x轴的范围，后两个调整y轴的范围
```

可视化矩阵：

```matlab
>> A = magic(5)
>> imagesc(A)
```

![8](http://oss.pyaxy.xyz/img/p8.png)

`colorbar`可以在旁边加一个颜色对照表：

![10](http://oss.pyaxy.xyz/img/p9.png)



## MATLAB教程

### 基本操作

基本的数据运算，包括加减乘除。

逻辑运算：

```matlab
> 1 == 2	% flase
ans	= 0
> 1 ~= 2
ans = 1
> 1 && 0;
```

注：在matlab中`%`号表示注释，不等于用`~=`来判断，`;`用于阻止结果的输出，如上面代码的最后一个命令，加上`;`后无输出结果。

#### 打印输出变量

```matlab
> a = pi;
> a
a =	3.1416


> disp(a)
 3.1416
 
 
> disp(sprintf('2 decimals: %0.2f', a))
2 decimals: 3.14
```

最后一项命令为C语言的旧式语法，`sprintf()`命令返回一个字符串，再通过`disp()`命令输出。

#### 控制打印长度

```matlab
> 1 = pi;
> format long
a =	3.14159265358979
> format short
> a
a = 3.1416

```

#### 矩阵

```matlab
> A = [1 2; 3 4; 5 6]
A =
	1	2
	3	4
	5	6
```

其中`;`表示矩阵切换到下一行

```matlab
> v = 1:0.1:2
v =

  列 1 至 8

    1.0000    1.1000    1.2000    1.3000    1.4000    1.5000    1.6000    1.7000

  列 9 至 11

    1.8000    1.9000    2.0000
```

上述的命令的具体含义为，从1为起点，步长为0.1，一直增加到2的一个行向量，**如果不设置步长默认为1。**

##### 生成特殊矩阵

```matlab
>> A = ones(2,3)

A =

     1     1     1
     1     1     1
>> zeros(1,3)

ans =

     0     0     0
>> rand(3,3)

ans =

    0.8147    0.9134    0.2785
    0.9058    0.6324    0.5469
    0.1270    0.0975    0.9575
```

在`rand(3,3)`中，会生成一个3x3的矩阵，里面的元素全是位于0到1之间的随机值，`randn()`可以生成满足**高斯分布(正态分布)**的随机值，例如：

```matlab
>> w = -6 + sqrt(10) * (randn(1,10000));
>> hist(w);
```

结果为：

![p1](http://oss.pyaxy.xyz/img/p1.png)

```matlab
>> eye(4)
ans =

     1     0     0     0
     0     1     0     0
     0     0     1     0
     0     0     0     1
```

`eye()`表示生成单位矩阵

### 移动数据

```matlab
>> A = [1 2; 3 4; 5 6];
>> size(A)
ans =
	3	2
>> v = [1 2 3 4]
>> length(v)
ans = 4	%将会返回最大维度的大小，一般用于求向量的大小，而不是用于矩阵
>> pwd
ans = D://.....	%显示当前路径
>> cd 'C:\Users'
```

载入文件：

```matlab
>> load xxxx.txt
>> load('xxxx.txt')
>> who	%可以显示出当前所有的变量
>> whos %可以显示出当前所有变量的详细信息
>> clear X	%删除X变量
>> clear	%删除所有变量
>> save xxx.mat V	%保存文件，把变量V存储为xxx.mat的文件
```

定位元素：

```matlab
>> A = [1 2; 3 4; 5 6];
>> A(3,2)
ans =	6
>> A(2,:)	%":"表示该行或列所有的元素
ans =
	3	4
>> A([1 3], :)	%获取第一行和第三行的所有元素
ans =
	1	2
	5	6
>> A = [A, [100;200;300]]	%可以在右边加一列新的矩阵
A =
     1     2   100
     3     4   200
     5     6   300
>> A(:)	%把A中的所有元素放到一列中
ans =
     1
     3
     5
     2
     4
     6
   100
   200
   300
```

### 计算数据

* 矩阵的乘法

  ```matlab
  >> A = [1 2; 3 4; 5 6];
  >> B = [11 12 13; 14 15 16];
  >> A*B
  ans =
  
      39    42    45
      89    96   103
     139   150   161
  ```

  上面的为矩阵的直接乘法，若要单独对元素进行操作则应该使用`.`

  ```matlab
  >> A = [1 2; 3 4; 5 6];
  >> B = [11 12; 13 14; 15 16];
  >> A.*B
  ans =
  
      11    24
      39    56
      75    96
  ```

  使用`.`可以对元素进行操作，不限于乘法。

* 计算绝对值：

  使用`abs()`命令可以求绝对值

* 矩阵转置：

  ```matlab
  >> A = [1 2; 3 4; 5 6]
  A =
       1     2
       3     4
       5     6
  >> A'
  ans =
       1     3     5
       2     4     6
  ```

  使用标准引号`'`可以求得矩阵的转置

* 逻辑比较：

  ```matlab
  >> a = [1 15 2 0.5];
  >> a < 3
  ans =
     1   0   1   1
  ```

  符合返回1，不符合返回0
  
* `magic()`函数

  `magic(n)`函数将会返回一个n阶的幻方矩阵，该矩阵的特点是每行每列以及对角线上的元素和都相等。

  ```matlab
  >> magic(3)
  ans =
       8     1     6
       3     5     7
       4     9     2
  ```
  
* `find()`函数

  ```matlab
  >> a = [1 15 2 0.5];
  >> find(a < 3 )
  ans =
       1     3     4
  ```

  将会返回符合条件的索引
  
  ```matlab
  >> A = magic(3)
  ans =
       8     1     6
       3     5     7
       4     9     2
  >> [r c] = find(A>=7)
  r =
       1
       3
       2
  c =
       1
       2
       3
  ```
  
  上述代码返回了符合条件的行和列的索引，比如`A(1,1)`大于等于7，`A(3,2)`也大于等于7。

* 求和：

  ```matlab
  >> a = [1 15 2 0.5];
  >> sum(a)
  ans =
     18.5000
  ```

  使用`sum()`函数可以求一个向量中的所有元素之和

  另外有：

  ```matlab
  >> A = magic(9)
  A =
      47    58    69    80     1    12    23    34    45
      57    68    79     9    11    22    33    44    46
      67    78     8    10    21    32    43    54    56
      77     7    18    20    31    42    53    55    66
       6    17    19    30    41    52    63    65    76
      16    27    29    40    51    62    64    75     5
      26    28    39    50    61    72    74     4    15
      36    38    49    60    71    73     3    14    25
      37    48    59    70    81     2    13    24    35
  >> sum(A,1)
  ans =
     369   369   369   369   369   369   369   369   369
  ```

  `sum(A,1)`返回了每列的求和，及把第1维度即每行的元素求和。同理`sum(A,1)`返回每列的求和，及把第2维度即每列的元素求和。

  另外注意，**如果不注明维度，则默认求第一维度即每列的和。**

  如何求对角线的和：

  我们先使用`A.*eye(9)`来使得除了对角线外的所有元素均为0

  ```matlab
  >> A = magic(9);
  >> A.*eye(9)
  ans =
      47     0     0     0     0     0     0     0     0
       0    68     0     0     0     0     0     0     0
       0     0     8     0     0     0     0     0     0
       0     0     0    20     0     0     0     0     0
       0     0     0     0    41     0     0     0     0
       0     0     0     0     0    62     0     0     0
       0     0     0     0     0     0    74     0     0
       0     0     0     0     0     0     0    14     0
       0     0     0     0     0     0     0     0    35
  ```

  接下来只需求这个矩阵的所有元素之和：

  ```matlab
  >> sum(A.*eye(9), 'all')
  ans =
     369
  ```

  我们还可以使用`flipud()`命令来使单位矩阵垂直翻转来求另一条对角线的和：

  ```matlab
  >> A = magic(9);
  >> A.*flipud(eye(9))
  ans =
       0     0     0     0     0     0     0     0    45
       0     0     0     0     0     0     0    44     0
       0     0     0     0     0     0    43     0     0
       0     0     0     0     0    42     0     0     0
       0     0     0     0    41     0     0     0     0
       0     0     0    40     0     0     0     0     0
       0     0    39     0     0     0     0     0     0
       0    38     0     0     0     0     0     0     0
      37     0     0     0     0     0     0     0     0
  >> sum(A.*flipud(eye(9)), 'all')
  ans =
     369
  ```

  

  

* 求积：

  ```matlab
  >> a = [1 15 2 0.5];
  >> prod(a)
  ans =
  	15
  ```

* 取整：

  `floor()`函数可以对数字进行向下取整，`ceil()`函数可以对数字进行向上取整。

* `max()`函数

  * 对向量:

    ```matlab
    >> a = [1 15 2 0.5];
    >> max(a)
    ans = 
  	  15
    ```
    上述例子的`max()`函数返回了一个向量之中的最大值，如果要获取它的索引则有：

    ```matlab
    >> a = [1 15 2 0.5];
    >> [val, ind] = max(a)
    val =
        15
    ind =
         2
    ```
    其中`val`返回了最大元素的值，`ind`返回了其索引
    
  * 对矩阵：

    ```matlab
    >> A = magic(3)
    ans =
         8     1     6
         3     5     7
         4     9     2
    >> max(A,[],1)
    ans =
         8     9     7
    ```
  
    上面的结果返回了每列元素的最大值，后面的1表示对第一维度进行遍历，从第1行到第n行进行比较，返回最大值，从而求出每列最大的元素，同理有`max(A, [], 2)`来求得每行元素的最大值。
  
    当然要记得，**如果对一个矩阵进行如同`max(A)`一般的操作，则默认返回以第一维度求和即每列的最大值。**
  
    如果你想求得一个矩阵中最大的元素，则可以用以下方法：
  
    ```matlab
    >> max(max(A));
    >> max(A, [], 'all');
    ```
  
* 求逆矩阵：
  
  ```matlab
  >> pinv(A)
  ```
  
  使用`pinv()`来求矩阵的逆矩阵
  
### 数据绘制

```matlab
>> t=[0:0.01:1];
>> y1=sin(2*pi*4*t);
>> plot(t,y1)
```

上述命令可以简单的绘制出一个正弦函数：

![数据绘制](http://oss.pyaxy.xyz/img/p2.png)

我们接着输入：

```matlab
>> y2=cos(2*pi*4*t)
>> plot(t,y2);
```

这时你会发现，matlab抹除了之前绘制的sin函数，再绘制出了cos函数，要想把两个曲线绘制到同一个图上，我们可以这样做：

```matlab
>> plot(t,y1);
>> hold on;
>> plot(t,y2,'r');	%将曲线颜色设置为红色
```

`hold on`可以保留之前绘制的内容然后接着绘制新的内容：

![数据绘制3](http://oss.pyaxy.xyz/img/p3.png)

我们还可以在图上添加其他的数据：

```matlab
>> xlabel('time')	%给x轴加上标签
>> ylabel('value')	%给y轴加上标签
>> legend('sin','cos')	%在图上标明曲线的名字
>> title('my plot')	%给图取名字
```

![数据绘制4](http://oss.pyaxy.xyz/img/p4.png)

保存图像：

```matlab
>> print -dpng 'my Plot.png'
```

这会在当前路径保存图片，另外`close`可以把图像关闭

在两张图上绘制：

```matlab
>> figure(1);
>> plot(t,y1);
>> figure(2);
>> plot(t,y2);
```

![5](http://oss.pyaxy.xyz/img/p5.png)

这样我们就得到了两个图

在一个图里画多个独立的曲线：

```matlab
>> subplot(1,2,1);	%这个语句前两个参数表示把图分为1*2的格子，最后一个参数表示使用第一个格子
>> plot(t,y1);
```

![6](http://oss.pyaxy.xyz/img/p6.png)

```matlab
>> subplot(1,2,2);
>> plot(t,y2);
```

![7](http://oss.pyaxy.xyz/img/p7.png)

调整轴的范围：

```matlab
>> axis([0.5 1 -1 1])	%前两个调整x轴的范围，后两个调整y轴的范围
```

可视化矩阵：

```matlab
>> A = magic(5)
>> imagesc(A)
```

![8](http://oss.pyaxy.xyz/img/p8.png)

`colorbar`可以在旁边加一个颜色对照表：

![10](http://oss.pyaxy.xyz/img/p9.png)